|          |           `InooDB`（`MySQL` 5.1 之后默认存储引擎）           |                           `MyISAM`                           |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   事务   |                             支持                             |                 不支持，但每次索引都是原子的                 |
|   外键   |                             支持                             |                            不支持                            |
|  锁力度  |                        表级锁、行级锁                        |                            表级锁                            |
|   索引   | ①主键索引是聚集索引，其他索引为非聚集索引 ②索引存放于表空间③非主键索引的叶子节点存放的是主键索引 | ①非聚集索引 ②索引存放于文件③索引的叶子节点存放的是数据的地址 |
| 全文索引 |                            不支持                            |                             支持                             |
| 哈希索引 |                             支持                             |                            不支持                            |

```sql
-- 查询数据库存储引擎
SHOW ENGINES;
-- 修改默认的存储引擎
DEFAULT-STORAGE-ENGINE = MYISAM;
-- 修改表的存储隐墙
ALTER TABLE t_name ENGINE = INNODB;

-- 查看表的索引
SHOW INDEX FROM t_name;
-- 创建索引
CREATE INDEX index_name ON t_name(col_name);

ALTER TABLE t_name ADD INDEX index_name(col_name);
ALTER TABLE t_name ADD UNIQUE INDEX index_name(col_name);
```

索引：是一种已排序的数据结构，提高查询效率。

|                    | 主键索引 | 唯一索引 |
| :----------------: | :------: | :------: |
|      数据唯一      |   保证   |   保证   |
|      `null`值      |  不可以  |   可以   |
| 每张表可创建的个数 |   一个   |   多个   |

`MySQL`索引的底层实现是`B+`树。数据存放于叶子节点，叶子节点间有指向下一个相邻叶子节点的访问指针，便于遍历。

聚集索引：索引顺序和数据的存储顺序相同，叶子节点包含完整的数据。

非聚集索引：索引顺序和数据的存储顺序不同，叶子节点包含数据地址，需要二次查询。

复合索引：多个列组合构建的索引。需要符合最左前缀原则(`WHERE`子句中使用最频繁的列放在最左侧)，最左匹配原则(自左向右匹配，直到遇到范围查询后，停止匹配)。

```sql
-- 复合索引(a,b,c,d)
SELECT * FROM t_name 
WHERE a=? AND b=? AND c>? AND d=?; -- 走索引 a,b,c
WHERE a=? AND b>? ; -- 走索引 a,b
WHERE a=? AND c=? ; -- 走索引 a
WHERE b=? AND c>? ; -- 不走索引
```

索引命中：

1. 先导模糊查询 `LIKE '%XX'` 不走索引。
2. 负向条件`!=、<>、NOT IN、NOT EXISTS、NOT LIKE`不走索引。
3. 联合索引不符合最左前缀原则，不走索引。
4. 查询条件中，索引列进行计算，全表扫描。`WHERE a < 1 + 2`。
5. `OR`语句前后不同时使用索引，不走索引。

索引优化：

1. 索引列尽量散列，不重复。
2. 索引列的值长度尽量小，索引文件小，减少维护成本。
3. 修改多的列避免创建索引。
4. 选择查询较多的列创建索引。
5. 索引列尽量使用`NOT NULL 或 DEFAULT`进行约束

| B+树                         | B树                                                          | 红黑树                                     | 二叉树                                               |
| :--------------------------- | :----------------------------------------------------------- | :----------------------------------------- | ---------------------------------------------------- |
| `IO`次数少，叶子节点存有数据 | 所有节点都会保存数据，相对`B+树`，节点保存的指针少，同等数量下，树的深度大，`IO`次数多，查询性能差 | 树的高度随着数据量的增加而增加，`IO`次数多 | 树的高度不均匀，且深度随数据的增多而增大，`IO`次数多 |

创建数据库表的三范式（减少数据冗余，体积小，更新快；查询有事需要关联，难以使用索引）

1. 列尽量拆分到不可拆分。
2. 每条记录都和唯一的主键关联。
3. 任何列都是独立的。