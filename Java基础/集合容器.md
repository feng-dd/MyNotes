# 集合容器

length：数组的属性
length()：获取字符串长度
size()：泛型集合的元素个数

## fail-fast 和 fail-safe 迭代器的区别

- fail-fast：直接在**容器**上进行，在遍历过程中，一旦发现容器中的数据被修改，就会立刻抛出 ConcurrentModificationException 异常从而导致遍历失败。常⻅的使用 fail-fast 方式的容器有 HashMap 和 ArrayList 等。
  - 序列化和迭代时，会比较前后的 modCount（记录结构改变的次数）是否相同，改变了就会抛出ConcurrentModificationException 。
- fail-safe：这种遍历基于**容器的一个克隆**。因此对容器中的内容修改不影响遍历。常⻅的使用 fail-safe 方式遍历的容器有 ConcurrentHashMap 和 CopyOnWriteArrayList。

## Collection接口

### Set接口

元素唯一但无序（无序不是指元素大小的排序，而是插入的先后顺序）

#### HashSet

- 底层：hashMap；HashMap 的 Key 即 HashSet 存储的元素，Value 是系统自定义一个名为 PRESENT 的 Object 类型常量。判断元素是否相同时，先比较 hashCode，相同后再利用 equals 比较，查询效率O(1)。
- 去重：继承Object类的hashCode()和equals()；
  - hashCode()：根据定义的哈希规则将对象内存地址转换成一个hash码。
  - equals()：当两个对象的hashCode相同时，对比对象的内存地址是否相同；返回结果为true，则添加成功，反之，则失败。

#### LinkedHashSet

继承了HashSet，通过 LinkedHashMap 实现，使用双向链表维护了元素的插入顺序。

#### TreeSet

通过TreeMap实现，底层使用红黑树结构存储元素；按照比较规则将新元素插入指定位置，保证元素有序，查询、删除、修改的效率O(logN)。

### List

元素不唯一但有序（有序不是指元素大小的排序，而是插入的先后顺序）

#### ArrayList

- 底层：动态的对象数组 Object[]（内存开辟一段连续的空间存储）
- 查询：支持随机访问
- 容量：可变
- 修改：指定位置插入/删除，需要对新插入位置之后的所有元素都向后/向前移动一位。
- 扩容：初始化数组大小为10，当插入时容量不足，出发扩容grow()， 扩容 1.5 倍，newSize = oldSize + oldSize >> 1，旧数组复制到新数组，替换。若扩容后容量还是不够，则扩容到实际需要的容量。
- 并发安全性：非线程安全
- 随机查询效率O(1)，插入和删除O(N-i)，i是插入或删除的元素下标，当i为N（即追加到末尾时），效率为O(1)。

#### LinkedList

- 底层：双向循环链表（JDK1.6及之前）、双向链表（JDK1.7开始）
- 查询：因链表的first、last指针，故只能顺序访问，不支持随机访问。
- 修改：通过add(E e)插入或者删除元素，时间复杂度近似O(1)；如果指定位置元素插入add(int index, E e)或删除，时间复杂度近似与O(N)（因为需要将指针移动到指定位置）。
- 并发安全性：非线程安全
- 不支持随机查询，对元素索引需要进行遍历；插入效率较高，因为不需要移动元素。

#### Vector

- 与 ArrayList 相似
- 扩容 2 倍
- 并发安全性：线程安全
- 是线程安全版的ArrayList，几乎所有的方法都通过Synchronized做了同步。

## Map

存储：键值对形式
key 唯一，value 可重复

### LinkedHashMap

- LinkedHashMap 继承自 HashMap，由数组和链表或红黑树组成
- 另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序，同时通过对链表进行相应的操作，实现了**顺序访问**相关逻辑。

### TreeMap

红黑树(自平衡的排序二叉树)

### HashTable

- 底层：数组+链表
- 元素：key 和 value 都不能为 null，插入时会抛出 NullPointerException。
- 扩容：默认数组初始化容量为11，扩容 2n+1 ；若初始化时指定容量，直接使用指定的大小。
- 解决hash冲突的方法：拉链法（将链表和数组相结合，数组的每一格是一个链表；当hash冲突时，将冲突的值放如链表中）。
- 并发安全性：线程安全
- 是线程安全版的HashMap，几乎所有的方法都有Synchronized关键字修饰。

![image-20220909171748178](/Users/murphy/Library/Application Support/typora-user-images/image-20220909171748178.png)

### HashMap

- 底层：JDK1.7：数组+链表；JDK1.8：数组+链表/红黑树（链表长度大于8且数组容量大于64时，转换为红黑树）
- 元素：key 只能有一个为null，value不限制。get(null) 会抛出 NullPointerException。
- 扩容：默认数组初始化容量为16，扩容 2n；若初始化指定容量，会将其扩容为 2 的幂次方大小。
- 解决hash冲突的方法：拉链法（将链表和数组相结合，数组的每一格是一个链表；当hash冲突时，将冲突的值放如链表中）。
- 并发安全性：非线程安全
- 是HashTable的轻量级实现

#### put()

1.判断数组是否为空，不为空继续，为空 resize()，再继续；
2.通过扰动函数（hash方法）计算 key 的hashCode得到hash，再根据（n-1）& hash（即取模运算）得到数组下标，插入/覆盖；

- 如果下标元素为空，添加第一个节点，插入键值对，此时为链表结构。

- 如果下标元素不为空，判断 key值与链首key值是否相同(equals)；
  相同，直接覆盖；
  不同，判断下标元素是否是红黑树；
	是，向树中插入；
	不是，遍历链表，判断链表长度是否大于8；
	
	- 大于，判断数组长度是否>=64；
    - 大于，才会将链表转换为红黑树（减少搜索时间），向树中插入；
    - 小于，对数组进行扩容；
  - 不大于，遍历链表，若 key 存在，覆盖；不存在，头插法插入到链表头部；
  
  3.size++，若 size++ > thredhold ，resize()。

#### 扩容

- capacity：容量（数组容量）
- thredhold 阈值	
- loadFactor负载因子，默认 0.75f
- size：元素总量
- thredhold = capacity * loadFactor

当 size >= thredhold 时，需要扩容，每次 resize() 是原来容量的2倍，新的数组替换老的数组，并重新计算key的下标。

max_capacity 为 2^30 ，当容量被扩充到 max_cacpacity 时，thredhold 固定为 Integer.MAX_VALUE，即 2^31-1。

#### HashMap 的长度为什么是2的幂次方？

原因：为了使 HashMap 存取高效，减少碰撞（不同的key算出相同的下标，也叫冲突），数据分散均匀。

原理：计算数组下标时，需要对数组长度进行取模，余数即存放的数组下标（`hash % n `，n 就是数组长度）

取模运算：当除数是2的幂次方时，`hash % n == hash & (n-1)`，**相较于 % ，二进制的位运算效率更高。**

#### HashMap 多线程操作导致死循环问题

原因：JDK1.8之前，并发put()时的触发 resize() 后，rehash(重新计算hash值) 会造成元素之间会形成一个循环链表，使得后续 get() 时出现死循环。

## 比较器

### Comparable 接口

- java.lang 包；

- 排序方法：compareTo(Object obj) 排序方法；

- 内比较器，String、Byte、Date 等都实现了该接口。

  `o1.compareTo(o2)` 
  升序
  o1 > o2 return > 0	
  o1 = o2 return = 0
  o1 < o2 return < 0

  降序反之

### Comparator 接口

- java.util 包

- 排序方法：compare(Object o1,Object o2) 排序方法；

- 外比较器，自定义比较器，使用比较器对象对相比较的对象进行比较。

- `comparator.compare(o1,o2)` 
  升序
  o1 > o2 return > 0	
  o1 = o2 return = 0
  o1 < o2 return < 0

  降序反之

`Collections.sort(os,comparator);` 使用集合工具的排序，将自定义比较器放入。

## JUC

### CopyOnWriteArrayList

- J.U.C 包下的类
- 读写分离：读操作不加锁，在原数组上；写操作加锁(Lock)，防止并发写入的数据丢失，在原数组的拷贝上进行，结束后将原数组指向拷贝。
- 优：多线程并发中,写操作的同时，不影响其读操作，提高了读操作的性能，读多写少的场景。
- 缺：写操作需要复制数组，占内存；当写操作没有同步到数组时，读取的数据没有实时性。

### ConcurrentHashMap

#### JDK1.7：HashMap的基础上添加了分段锁

ConcurrentHashMap 包含一个 Segment 数组，一个 Segment 元素包含 一个 HashEntry 数组，每个 HashEntry 元素是一个链表。也就是一个 Segment 元素对应多个链表。
每个 Segment 都有一个锁（Segment 继承了 ReentrantLock），当对 HashEntry 数组进行修改时，需要先获取 对应的 segment 的锁。

![image-20220909171817834](/Users/murphy/Library/Application Support/typora-user-images/image-20220909171817834.png)

#### JDK1.8：与 HashMap 相同，数组+链表/红黑树

使用 Synchronized 和 CAS 保证并发安全，在链表头部和红黑树的首节点加锁，只要不发生hash冲突时，就不会发生并发。

**TreeBin**：红黑二叉树节点

**Node**：链表节点

![image-20220909171914659](/Users/murphy/Library/Application Support/typora-user-images/image-20220909171914659.png)

## 如何选用集合?

主要根据集合的特点来选用

需要根据键值获取到元素值时就选用Map接口下的集合：需要排序时选择TreeMap，不需要排序时就选择HashMap，需要保证线程安全就选用ConcurrentHashMap

当我们只需要存放元素值时，就选择实现Collection接口的集合：需要保证元素唯一时选择实现Set接口的集合，比如TreeSet或HashSet，不需要就选择实现List接口的集合：比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。
