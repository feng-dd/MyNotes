## 基本概念

### 进程与线程

> 进程：系统资源调度和分配的基本单位。
>
> 线程：CPU调度和分配的基本单位。
>
> 1. 一个系统至少有一个进程，一个进程至少有一个线程，线程也被称作轻量级进程。
> 2. 进程之间相互独立，而同一个进程内的线程共享进程的堆和方法区（JDK1.8后改为元空间），但线程有自己私有的程序计数器、虚拟机栈和本地方法栈，所以线程之间通信开销更小。
> 3. 同一个进程中的线程切换开销小。

### 守护线程是什么？

Java中提供了两种线程，用户线程、守护线程；

守护线程优先度很低，当系统中没有用户线程时，守护线程就会退出；

常见的有GC线程，用于垃圾回收处理；

可以在创建线程时设置`setDaemon(true)`。

### 协程

- 一般多个协程对应一个内核态线程，多个协程间切换，实际仍是一个线程在运行；
- 相比于线程更加轻量级，协程切换在用户态，线程切换时需要在内核态进行，系统开销更小；
- 协程是程序中的一个代码流程，而线程时CPU资源调度的单位，协程需要依托于线程执行；
- 线程是抢占式资源调度，协程则是非抢占式资源调度，需要用户主动释放资源切换到其他协程，所以同一时间只有一个协程在运行。
- 线程和进程是同步的，协程是异步的。

### 并发和并行

> 并发：同一时间段内，多个任务都在执行（单位时间内不一定同时执行）。
>
> 并行：单位时间内，多个任务同时执行。

==多线程任务处理提高了CPU的使用率，可以加快任务的处理效率，当然也带来了线程安全问题，以及可能产生的死锁问题。==

## JAVA线程状态流转

> Thread 类中定义了 State 枚举类，包含`六`个状态：
>
> - NEW：新建状态。
> - RUNNABLE：可运行(就绪)/运行状态。
> - BLOCKED：阻塞状态。
> - WAITING：无限期等待状态。
> - TIMED_WAITING：限期等待状态。
> - TERMINATED：终止状态。

![image-20210512171138153](https://i.loli.net/2021/05/12/Y8OVNEze6Dq1c2S.png)

<!-- LockSupport 线程阻塞工具类 -->

### 1、新建（New）

> 创建后未调用start()方法

### 2、运行（Runnable）

> 就绪状态（Ready）：新建状态下的线程对象，被其它线程调用了 start() 方法，用来启动该线程；该状态下，获取到对象的同步锁后，等待CPU调度执行。
>
> 运行中（Running）：获取到CPU时间片，开始执行；要进入该状态，只能通过就绪状态。

当线程被挂起[^1]或调用了线程的`yield()`方法时，会进入就绪状态。

线程调用yield()，让出CPU时间片，和优先级相同的线程竞争CPU时间片，竞争成功，继续执行，失败，会进入就绪状态，不释放锁。

### 3、阻塞（Blocked）

>  线程阻塞于锁。

1. 线程在获取synchronized同步锁失败（因为其它线程占用），进入同步阻塞状态，进入对象锁的锁池中。
2. IO阻塞：线程不释放锁，等待 I/O 处理结束，进入就绪状态。

### 4、等待状态(WAITING)

>  由于某种原因放弃了CPU的使用权，暂停运行，直到进入就绪状态，才有机会重新进入运行状态。

1. wait()：线程会释放锁，进入等待队列中。线程调用notify()/notifyAll()退出，之后需要再次获取对象的同步锁，才能进入就绪状态。
2. join()：等待插队的线程执行完毕，线程进入就绪状态。会释放插队线程对象的锁（`threadX.join()`，threadX这个线程对象的锁会被释放，而不是父线程所持有的对象锁[^3])。
3. 调用`LockSupport.park()`[^2]进入无限期等待状态；调用`LockSupport.unpark(Thread)`回到运行状态。

### 5、超时等待状态(TIEM_WAITING)

> 由于某种原因放弃了CPU的使用权，暂停运行，直到进入就绪状态，才有机会重新进入运行状态。

1. 有 Timeout 参数的 join()：不释放对象的同步锁，时间结束或等待插队的线程执行完毕，进入就绪状态。

2. 有 Timeout 参数的 wait()：时间结束或线程调用了`notify()/notifyAll()`后退出，之后需要再次获取对象的同步锁，才能进入就绪状态。

3. sleep()：不释放对象的同步锁，需要等待睡眠时间结束，才可以进入到就绪状态。

4. 调用`LockSupport.parkNanos()/parkUntil()`进入限期等待状态；调用`LockSupport.unpark(Thread)`回到运行状态。

### 6、终止状态(Terminated)

> 线程执行完毕，或产生异常退出了 run()方法。

### 线程中断

```java
Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("正在执行");
                try {
                    while (!Thread.currentThread().isInterrupted()) {
                        System.out.println("休眠");
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() 
                                       + "(" + Thread.currentThread().getState() + ") 线程中断");
                }
            }
        }, "t1");

System.out.println(t1.getName() + "[start before] state：(" + t1.getState() + ")");
t1.start();
System.out.println(t1.getName() + "[start after] state：(" + t1.getState() + ")");

TimeUnit.MILLISECONDS.sleep(300);
System.out.println(t1.getName() + "[interrupt before] state：(" 
                   + t1.getState() + "),isInterrupted: (" + t1.isInterrupted() + ")");
t1.interrupt();
System.out.println(t1.getName() + "[interrupting] state：(" 
                   + t1.getState() + "), isInterrupted: (" + t1.isInterrupted() + ")");
TimeUnit.MILLISECONDS.sleep(300);
System.out.println(t1.getName() + "[interrupt after] state：(" 
                   + t1.getState() + "), isInterrupted: (" + t1.isInterrupted() + ")");
```

> t1[start before] state：(NEW)
> t1[start after] state：(RUNNABLE)
> 正在执行
> 休眠
> 休眠
> 休眠
> t1[interrupt before] state：(TIMED_WAITING), isInterrupted: (false)
> t1[interrupting] state：(TIMED_WAITING), isInterrupted: (true)
> t1(RUNNABLE) 线程中断
> t1[interrupt after] state：(TERMINATED), isInterrupted: (false)

通过调用`interrupt()`设置线程中断标识，由`isInterrupted()查询线程的中断状态。

当线程处于`TIME_WAITING/WAITING`时，调用线程的`interrupted()`会抛出中断异常。

### 锁池&等待池

> 每个对象都有两个池，锁(monitor)池(阻塞队列)和等待池(等待队列)。

- 锁池：假设线程A已经拥有了某个对象（注意:不是类）的锁，而其它的线程想要调用这个对象的某个synchronized方法（或者synchronized块），由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。
- 等待池：假设线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁（因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁），同时线程A就进入到了该对象的等待池中。线程B调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果线程B调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池。

## 使用线程的方式

### 一、继承Thread类

```java
public class MyThread extends Thread {
    public void run() {
        //...
    }
}

public static void main (String args[]){
    MyThread t = new MyThread();
    t.start();
}
```

> 1.重写 run() 方法，该方法体就是线程需要完成的任务（线程执行体）
>
> 2.创建线程对象
>
> 3.启动线程

### 二、实现Runnable接口

```java
public class MyRunnable implements Runnable {
    public void run(){
        //...
    }
}

public static void main (String args[]){
    MyRunnable mr = new MyRunnable();
    Thread t = new Thread(mr);
    t.start();
    //或 new Thread (new MyRunnable()).start();
}
```

> 1.实现 Runable 接口的 run() 方法
>
> 2.将 Runnable 实现类对象作为参数，创建 Thread 对象
>
> 3.通过 Thread 对象调用 start()方法，启动线程

### 三、实现Callable接口

```java
public class MyCallable implements Callable {
    public Integer call(){
        //...
        return 123;
    }
}

public static void main (String args[]){
   MyCallable mc = new MyCallable();
   FutureTask ft = new FutureTask(mc);
   Thread t = new Thread(ft);
   t.start();
   system.out.print(ft.get());
}
```

> 与 Runnable 接口相比，Callable 接口可以有返回值，通过 FutrueTask 封装返回值
>
> 1.实现 Callable 接口的 call() 方法
>
> 2.使用 FutrueTask 类包装 Callable 实现类对象，将 call() 方法的返回值封装到FutrueTask 对象中
>
> 3.将 FutureTask 对象作为参数，创建 Thread 对象
>
> 4.通过 Thread 对象调用 start()方法，启动线程
>
> 5.通过 FutureTask 对象的 get() 方法，获取返回值

### 实现接口 VS 继承Thread

实现接口相比更好

1. Java不支持多继承，继承 Thread 类后，无法在继承其他类；接口可以实现多个。
2. 多个线程可以共享同一个接口的实现类对象，开销比较小；但要访问当前线程，必须调用 Thread.currentThread()方法。

==创建线程的方式只有继承`Thread`类和实现`Runnable`接口两种，而使用线程的方式有以上几种方式。==

### start() & run()

new ⼀个 Thread，线程进⼊了新建状态，调⽤ start() ⽅法，会使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏ run() ⽅法的内容。

但是，直接执⾏ run() ⽅法，会把 run()⽅法当成⼀个 main 线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。-->

## 多线程协作

- `join()`：「Thread类方法」，子线程调用join()，就会抢占cpu执行任务，当任务完成或超时，才会继续执行父线程的任务。

- `wait() notify() notifyAll()`：`Object`的方法；调用该对象的`wait()`方法，会将线程挂起，放入对象锁的等待队列中，等待其他线程调用该对象的`notify()或notifyAll()`方法唤醒线程；`notify()`方法时随机唤醒一个线程，`notifyAll()`方法时唤醒所有线程。都只能在同步方法或同步代码块中使用，否则会引起`IllegalMonitorStateException`异常。

- `wait()和sleep()方法的区别`

  > 1. `wait()`是`Object`的方法，`sleep()`是`Thread`类的静态方法。
  > 2. `wait()`会释放锁，`sleep()`不会。

## 线程间通信

线程之间通过对共享资源的互斥访问（加锁）实现通信。

实现方式有两种：`Synchronized、ReentrantLock`

读写锁：`Lock接口的ReadWriteLock`类：读共享，写排他。

```java
ReadWriteLock lock = new ReentrantReadWriteLock();
Lock readLock = lock.readLock();
Lock writeLock = lock.writeLock();
```

## 并发编程

### 并发安全

访问统计

```java
/**
 * 访问接口计数器
 */
public class AccessCount {
    /**
     * 访问次数
     */
    private Integer accessCount;
    
    public void access() {
        accessCount ++;
    } 
}
```

在单线程中，这部分代码可以保证访问接口计数，但多线程中却无法保证。

accessCount ++ 在Java内存模型（JMM）中的过程如下：

1. 线程从主内存中 Copy accessCount=0 到工作内存；
2. 线程从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
3. 线程将 accessCount=1 刷新到主内存中。

在多线程竞争的情况下，可能会变为：

1. 线程1从主内存中 Copy accessCount=0 到工作内存；
2. 线程从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
3. 线程2从主内存中 Copy accessCount=0 到工作内存；
4. 线程2从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
5. 线程1、2无论先后顺序，将 accessCount=1 刷新到主内存中。

当线程1、2都运行结束，主内存中 accessCoun=1，而不是我们期望的2；这就是我们所说多线程访问共享变量所产生的线程安全问题。

### 并发编程的三大特性

#### 原子性

对共享变量的多个操作是原子的，要么全部成功，要么全部失败，中途不会因为其他因素中断。

比如 accessCount ++ ，如果线程从主存读取、+1、写回主存这三个步骤是原子的，那么数据与预期一定是相符的。

#### 可见性

一个线程对共享变量的修改对于其他线程是立马可见的，

#### 有序性

happen-before原则保证指令顺序执行。

##### 指令重排序

Java编译器和系统处理器为了提高性能，可能会对指令进行重排序

##### 重排序流程

![image-20220916152544851](/Users/murphy/Library/Application Support/typora-user-images/image-20220916152544851.png)

Java编译器重排序：（happen-before会禁止部分特殊的重排序）

​	编译器优化重排序：在不改变单线程语义的情况，对指令进行重排序。

处理器重排序：（Java编译器会跟据处理器重排序规则在生成指令时，在特定指令前后添加相应的内存屏障「CPU指令」，防止处理器重排序）

​	指令级并行重排序

​	内存系统重排序

==以上三种重排序在多线程情况下都可能出现并发安全问题。==

### happen-before原则

1. 对象终结规则：一个对象的初始化完成先于对象的finalize()。
2. 监视器锁规则：一个锁的unlock操作早于后续对该锁的lock操作
3. 程序顺序规则：一个线程内按代码的书写顺序执行。
4. 传递规则：如果A操作先于B操作，B操作先于C操作，那么A操作先于C操作。
5. 线程启动规则：一个线程的start()早于线程的任意操作。
6. 线程终结规则：一个线程的终结检测晚于线程的其它操作。
7. 线程中断规则：一个线程的interrput()早于线程被检测出中断。
8. volatile规则：对volatile变量的写操作早于它的其它操作。

### 解决并发安全问题

#### 无锁方式

------

##### Volatile关键字

> 1. 防止指令重排。
> 2. 保证内存可见性；volatile声明的变量，只能在主存中读写，保证数据的更新是内存可见的，每个线程都可以获得最新的数据。
>    - 写操作后有`store`指令（将修改的数据刷新到主内存）：当线程修改了volatile变量时，立刻强制刷新到主存；若其他线程的工作内存中有包含变量的副本时，强制过期失效变量副本，不允许读和使用；
>    - 读操作前有`load`指令（必须从主内存读取新值）：其他线程在运行过程中需要读取变量时，需要从主存中重新读取。
> 3. 不保证原子性。非线程安全。

![](https://i.loli.net/2021/05/26/jY6PACquFDdTVJM.png)

###### 内存屏障（内存栅栏）

CPU级别禁止指令排序，通过一组处理器指令、禁止屏障前后的指令顺序互换。

- LoadLoad（Load1 | Barrier | Load2）
- StoreStore（Store1 | Barrier | Store2）
- LoadStore（Load1 | Barrier | Store2）
- StoreLoad（Store1 | Barrier | Load2）

##### CAS（乐观锁）

> `V`：主内存中的值；`E`：期望值；`N`：新值。
>
> ```java
> V == E;
> E = N;
> ```
>
> `ABA`问题：
>
> 1. 基本类型数据，无影响。
> 2. 引用类型数据，加上版本号，在比较时连带版本号一起比较。

#### ThreadLocal

> ThreadLocal 对象的意义从字面就可以看出，为线程提供本地存放私有数据。

![image-20210518114120256](https://i.loli.net/2021/05/26/c4lbUJK9MqE6Cfk.png)

```JAVA
// ThreadLocal  类的 set() get() 方法
public void set(T value) {
	Thread t = Thread.currentThread(); 
    ThreadLocalMap map = getMap(t); 
    if (map != null) 
		map.set(this, value); 
    else
		createMap(t, value);
}

ThreadLocalMap getMap(Thread t) {
	return t.threadLocals;
}
```

> ThreadLocalMap 是 ThreadLocal 的静态内部类。
>
> Thread 类中有两个 ThreadLocalMap 变量。
>
> 也就是说，每个线程都有一个 ThreadLocalMap 用来存放线程私有的数据，`ThreadLocal.getMap(Thread t)`可以获取到线程的 ThreadLocalMap；
>
> ThreadLocalMap 的 Entry 对象是 ThreadLocal 对象和其对应 set() 的 Object 值。

`ThreadLocalMap 中使用的 Key 是 ThreadLocal 的弱引用，而 value 是强引用；`

`当 ThreadLocal 没有外部强引用时，GC后，会出现 Key 为 null 的 Entry，从而产生内存泄漏；`

`ThreadLocalMap 在实现 set()、get()、remove()  方法时，会清理掉 Key 为 null 的记录；`

`建议使用完 ThreadLocal 方法后，手动调用 remove()。`

#### 有锁方式

##### `Synchronized`

> 底层通过`JVM`实现。获取对象的`Monitor`，才可以访问同步代码。
>
> 两个线程同时访问同步代码块时，一个线程进入同步代码块，另一个线程就必须等待。
>
> 可见性：一个线程对临界资源的改变，对于其他线程是可见的；也就是线程在使用变量时，必须从主内存中读取。
>
> > `synchronized`：线程获取锁时，清空工作内存，在主存中拷贝最新值到工作内存，执行完毕将共享变量的值刷新回主内存中，然后释放锁。
>
> `happen-before`原则、`JMM - Java`内存模型保证了可见性。
>
> 原子性：线程对临界资源的操作是原子的，不可拆分为更多的步骤。否则会造成数据不一致的问题。如`count++`。
>
> 可重入锁：线程可以进入任意一个已获得锁的同步代码块；在一定程度上避免了死锁。
>
> > 1. 同步方法`m1()、m2()`是同一个对象锁，`m1()`方法中调用了`m2()`方法，线程调用`m1()`方法，表示已经获取到对象锁，当需要调用`m2()`方法时，不需要重新获取锁就可以调用。
> > 2. 子类重写了父类的同步方法`m()`，并在代码中调用了父类的`m()`[`super.m()`]，线程获取到子类的锁调用子类的`m()`，当执行`super.m()`时，可以直接拿到锁。**前提是锁的同一个对象或者`class`**。
> >
> > `PS`：`AQS`中维护了一个`state`，线程获取锁时，会将`state+1`，释放锁会`-1`,可重入锁可以在锁上加锁，想要彻底释放锁，`state-1==0`其他线程才可以去申请这个锁。
>
> 锁升级（可升不可降，偏向锁可以被重置为无锁状态）：对象头中`MarkWord`信息
>
> |      锁状态      | 是否偏向锁`(1 bit)` | 锁标志位`(2 bit)` |                             情景                             | 参数                                  |
> | :--------------: | :-----------------: | :---------------: | :----------------------------------------------------------: | ------------------------------------- |
> |       无锁       |          0          |        01         |                                                              |                                       |
> |      偏向锁      |          1          |        01         |    大多数情下，锁一直由一个线程多次申请，降低申请锁的代价    | 关闭：`-XX:-UseBiasedLocking = false` |
> | 轻量级锁(自旋锁) |                     |        00         | 竞争锁的线程数量较少，且线程持有锁的时间短，避免`CPU`从用户态转到内核态带来的开销 |                                       |
> |     重量级锁     |                     |        10         | 自旋会消耗`CPU`，当自旋时间过长，如自旋次数达到`10`次，线程还是无法获取锁，升级为重量级锁 |                                       |
>
> 锁粗化：避免频繁加减锁的操作，将锁的范围扩大。
>
> ```java
> for(int i = 0 ; i < 100 ; i++){
>     synchronized(lock){
>     }
> }
> //JVM 锁粗化
> synchronized(lock){
>     for(int i = 0 ; i < 100 ; i++){
>     }
> }
> ```
>
> 锁消除：`JVM`在即时编译(`JIT`：当代码即将第一次运行时进行编译)时，去除不存在资源竞争的锁，节省无意义的请求锁时间。例如：`StringBuffer的append()`是线程安全的，当我们只在线程内部将`StringBuffer`当做局部变量使用时，嗲用`append()`方法，不存在锁竞争的情况，会发生锁消除。

```java
// 同步代码块
public void m(){
    synchronozed(this){
    	do something;
	}
    synchronozed(T.class){
    	do something;
	}
}
// 同步方法 等价于 synchronozed(this)
public synchronozed void m2(){
    do something;
}
// 同步静态方法 等价于 synchronozed(T.class)
public synchronozed static void m2(){
    do something;
}
```

##### `ReentrantLock`

> 底层通过`JDK`实现，会受到版本影响。通过`CAS`进行操作。
>
> 可重入锁、公平锁(默认非公平锁)、可尝试获取(`tryLock()`、可中断(`lockInterruptibly()`)。

------

#### Synchronized关键字

> Synchronized 关键字是Java防止多线程程序访问临界资源(线程共享资源)可能产生线程安全所创建的，底层是依赖于操作系统的`Mutex Lock（互斥锁）`实现的。操作底层加解锁，需要从用户态转换到内核态，比较耗时。
>
> Java 6 之后对 Synchronized 关键字做了优化，通过`自旋锁`、偏向锁、轻量级锁、锁消除、锁粗化等减少锁的开销。

#### Synchronized 关键字使用

##### 一、对象加锁

> 对对象加锁，多个线程访问获取同一个对象锁是互斥的。

```java
public class MyLock {
    // 实例方法上使用，对对象加锁
    synchronized void methedA(){
        // todo some things
        ...
    }
    
    public static void main(String[] args) {
        // 在代码块上对对象加锁
        synchronized(this){
        	// todo some things
        	...
    	}
    } 
}
```

##### 二、类加锁

> 对类加锁，多个线程访问同一个类的锁是互斥的。

```java
public class MyLock {
    // 静态方法上使用，对类加锁
    synchronized static void methedA(){
        // todo some things
        ...
    }
    
    public static void main(String[] args) {
        // 在代码块上对类加锁
        synchronized(MyLock.class){
        	// todo some things
        	...
    	}
    } 
}
```

`PS：线程A调用一个实例对象的同步非静态方法，线程B调用这个实例对象的同步静态方法，是允许的，不会发生互斥，因为线程A访问的同步方法占用的是对象锁，而线程B访问的同步方法占用的是类锁。`

##### 三、双重检验锁实现单例

> 单例模式实现条件：
>
> 1. 私有化构造。
> 2. 公共静态方法提供实例。

```java
public class singleton {
    
	private volatile static Singleton instance;
    
	private singleton(){}
    
    public static singleton getInstance(){
        if(null == instance){
            synchronized(Singleton.class){
                if(null == instance){
                    instance = new singleton();
                }
            }
        }
        return instance;
    }
}
```

`线程获取对象实例时，需要先判断当前对象是否被创建，没有被创建就获取对象的类锁，再次校验有没有其他线程在当前线程获取锁前创建了对象，没有再创建对象。`

`此处volatile 的作用是防止在创建对象时JVM自动指令重排。`

`创建对象三个指令：`

1. `为instance开辟内存空间。`
2. `初始化对象。`
3. `将instance指向分配的内存地址`

`如果线程A在获取对象时，JVM将指令重排序为1-3-2，指令2完成后，线程B获取对象判断对象不为空，直接使用该对象，此时对象还未初始化。`

#### Synchronized 底层原理

> Synchronized 关键字底层是通过JVM实现的。

##### 一、同步代码块

> 通过 javap （javap -c -s -v -l）查看字节码，可以看到，同步代码块有两个明显指令：`monitorenter`、`monitorexit`。
>
> monitorenter：进入同步代码块；线程尝试获取对象监视器 Monitor 的持有权。
>
> monitorexit：退出同步代码块；线程释放对象监视器 Monitor 的持有权。

##### 二、同步方法

> 通过 javap （javap -c -s -v -l）查看字节码，可以看到，JVM中通过标识 `ACC_SYNCHRONIZED` 状态，表明该方法为同步方法。

`同步方法和同步代码块在指令集上的表现不同，但实质上都是获取对象监视器 Monitor 。`

`线程获取锁时，锁的计数器为0，表明锁可以被获取；`

`锁被获取后，锁的计数器会被置为1，表明锁已被占用；`

`线程释放锁后，锁的计数器会置为0，表明锁已被释放；`

`线程获取锁时，锁的计数器为1，线程会被阻塞，直到锁被其他线程释放，当前线程获取到锁为止。`

### Synchronized & volatile

|          | Synchronized                     | volatile                         |
| -------- | -------------------------------- | -------------------------------- |
| 线程安全 | 安全，可见性、原子性             | 非安全，保证可见性，不保证原子性 |
| 性能     | 慢                               | 快                               |
| 作用域   | 代码块、方法                     | 变量                             |
| 意义     | 保证多线程间访问临界资源的同步性 | 保证多线程间访问玲姐资源的可见性 |

### JMM Java内存模型 (Java Memory Model)

> JVM定义了Java内存模型，屏蔽了不同操作系统与底层硬件之间访问的差异，实现各个平台统一的内存访问效果。
>
> 在Java当前的内存模型下，线程对数据的操作方式是：
>
> 1. 将数据从主存拷贝副本到本地内存；
> 2. 线程从本地内存获取数据；
> 3. 线程将修改后的数据写入本地内存；
> 4. 本地内存将数据刷新到主存中。
>
> 多线程的情况下，就可能产生数据不一致的问题；当线程A从主存读取数据`count=0`到工作内存，线程读取工作内存修改`count=count+1`，此时线程B从主存中获取数据`count=0`到工作内存，修改`count=count+1`，此时数据就会是脏数据。

![image-20210517172051328](https://i.loli.net/2021/05/17/5Rzxl8OySB9XkUN.png)

### 死锁

![image-20210512212016258](https://i.loli.net/2021/05/12/6SBVq2FKZiuE9xG.png)

> 多个线程同时被阻塞；
>
> 线程A持有资源2、线程B持有资源1，线程A需要申请资源1、线程B需要申请资源2，线程A、B都阻塞。

#### 产生死锁的四个条件

1. 互斥条件：每个资源在任意时间只能由一个线程占用。
2. 请求和保持条件：一个线程/进程因请求资源而阻塞，对已获取的资源不释放。
3. 不剥夺条件：线程已获得的资源在未使用完之前，无法被其他线程强行剥夺，只能自己使用完后释放。
4. 循环等待条件：若干线程/进程间形成头尾相连的循环等待资源关系。

#### 避免死锁的方式

> 根据产生死锁的四个条件，我们只要破坏其中一个条件即可避免死锁。

1. 互斥条件无法破坏，锁的存在本身就是为了让线程互斥访问临界资源。
2. 破坏请求和保持条件：一次性申请所有需要的锁。
3. 破坏不剥夺条件：占用部分资源的线程在申请其他资源被阻塞时，可以主动释放自己占用的资源。
4. 破坏循环等待条件：资源按序申请，如线程必须先获取资源A再获取资源B。

## 线程池

> 池化技术（线程池、数据库连接池、HTTP连接池）的思想：
>
> 1. 减少获取资源的消耗；
> 2. 提高资源的利用率。

### 线程池的优点

1. 降低资源消耗：通过重复利用已创建的线程，减少创建和销毁线程带来的消耗。
2. 提高响应速度：当任务到达，无需等待创建线程也能立即执行。
3. 统一管理、优化、监控。

### 使用线程池

`《阿里开发规范手册》中建议使用 ThreadPoolExecutor 创建线程池，而不是Executors，原因是：`

1. `FixedThreadPool 和 SingleThreadExecutor：允许请求的队列⻓度为 Integer.MAX_VALUE，可能堆积⼤量的请求，从⽽导致 OOM。`
2. `CachedThreadPool 和 ScheduledThreadPool：允许创建的线程数量为 Integer.MAX_VALUE，可能会创建⼤量线程，从⽽导致 OOM。`

```java
/**
 * ⽤给定的初始参数创建⼀个新的ThreadPoolExecutor。 
 */
public ThreadPoolExecutor(int corePoolSize,
						  int maximumPoolSize, 
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue, 
                          ThreadFactory threadFactory, 
                          RejectedExecutionHandler handler
                         ) {
	if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0) 
        throw new IllegalArgumentException();
	if (workQueue == null || threadFactory == null || handler == null)
		throw new NullPointerException();
	this.corePoolSize = corePoolSize;
	this.maximumPoolSize = maximumPoolSize;
	this.workQueue = workQueue;
	this.keepAliveTime = unit.toNanos(keepAliveTime);
	this.threadFactory = threadFactory;
	this.handler = handler;
}
```

构造参数：

- corePoolSize：核心池的大小。
- maximumPoolSize：线程池的最大线程数量。
- keepAliveTime：线程空闲时间。
- workQueue：阻塞队列(任务缓存队列/任务等待队列)。
- handler：拒绝策略策略。

#### Executors提供的线程池类型

- FixedThreadPool ：  该⽅法返回⼀个固定线程数量的线程池。该线程池中的线程数量始终 不变。当有⼀个新的任务提交时，线程池中若有空闲线程，则⽴即执⾏。若没有，则新的任 务会被暂存在⼀个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 
- SingleThreadExecutor：  ⽅法返回⼀个只有⼀个线程的线程池。若多余⼀个任务被提交到 该线程池，任务会被保存在⼀个任务队列中，待线程空闲，按先⼊先出的顺序执⾏队列中的 任务。
- CachedThreadPool： 该⽅法返回⼀个可根据实际情况调整线程数量的线程池。线程池的 线程数量不确定，但若有空闲线程可以复⽤，则会优先使⽤可复⽤的线程。若所有线程均在 ⼯作，⼜有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执⾏完毕后， 将返回线程池进⾏复⽤。

### 线程池原理

![image-20210518152720184](https://i.loli.net/2021/05/18/wEbuiWIpO36naLB.png)



[^1]: 当前线程分配的CPU时间使用完，CPU会切换到其他线程执行，此时当前线程的状态即为挂起。
[^2]:[LockSupport](https://www.jianshu.com/p/f1f2cd289205)
[^3]:[join释放锁是哪个锁](https://blog.csdn.net/huanfeng_AI/article/details/107721863)