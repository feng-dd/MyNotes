# 基本概念

## 进程与线程

> 进程：系统资源调度和分配的基本单位。
>
> 线程：CPU调度和分配的基本单位。
>
> 1. 一个系统至少有一个进程，一个进程至少有一个线程，线程也被称作轻量级进程。
> 2. 进程之间相互独立，而同一个进程内的线程共享进程的堆和方法区（JDK1.8后改为元空间），但线程有自己私有的程序计数器、虚拟机栈和本地方法栈，所以线程之间通信开销更小。
> 3. 同一个进程中的线程切换开销小。

## 守护线程是什么？

Java中提供了两种线程，用户线程、守护线程；

守护线程优先度很低，当系统中没有用户线程时，守护线程就会退出；

常见的有GC线程，用于垃圾回收处理；

可以在创建线程时设置`setDaemon(true)`。

## 协程

- 一般多个协程对应一个内核态线程，多个协程间切换，实际仍是一个线程在运行；
- 相比于线程更加轻量级，协程切换在用户态，线程切换时需要在内核态进行，系统开销更小；
- 协程是程序中的一个代码流程，而线程时CPU资源调度的单位，协程需要依托于线程执行；
- 线程是抢占式资源调度，协程则是非抢占式资源调度，需要用户主动释放资源切换到其他协程，所以同一时间只有一个协程在运行。
- 线程和进程是同步的，协程是异步的。

## 并发和并行

> 并发：同一时间段内，多个任务都在执行（单位时间内不一定同时执行）。
>
> 并行：单位时间内，多个任务同时执行。

==多线程任务处理提高了CPU的使用率，可以加快任务的处理效率，当然也带来了线程安全问题，以及可能产生的死锁问题。==

# JAVA线程状态流转

> Thread 类中定义了 State 枚举类，包含`六`个状态：
>
> - NEW：新建状态。
> - RUNNABLE：可运行(就绪)/运行状态。
> - BLOCKED：阻塞状态。
> - WAITING：无限期等待状态。
> - TIMED_WAITING：限期等待状态。
> - TERMINATED：终止状态。

![image-20210512171138153](https://i.loli.net/2021/05/12/Y8OVNEze6Dq1c2S.png)

<!-- LockSupport 线程阻塞工具类 -->

## 1、新建（New）

> 创建后未调用`start()`方法

## 2、运行（Runnable）

> 就绪状态（Ready）：新建状态下的线程对象，被其它线程调用了 start() 方法，用来启动该线程；该状态下，获取到对象的同步锁后，等待CPU调度执行。
>
> 运行中（Running）：获取到CPU时间片，开始执行；要进入该状态，只能通过就绪状态。

当线程被挂起[^1]或调用了线程的`yield()`方法时，会进入就绪状态。

线程调用`yield()`，让出CPU时间片，和优先级相同的线程竞争CPU时间片，竞争成功，继续执行，失败，会进入就绪状态，不释放锁。

## 3、阻塞（Blocked）

>  线程阻塞于锁。

1. 线程在获取synchronized同步锁失败（因为其它线程占用），进入同步阻塞状态，进入对象锁的锁池中。
2. IO阻塞：线程不释放锁，等待 I/O 处理结束，进入就绪状态。

## 4、等待状态(WAITING)

>  由于某种原因放弃了CPU的使用权，暂停运行，直到进入就绪状态，才有机会重新进入运行状态。

1. `wait()`：线程会释放锁，进入等待队列中。线程调用notify()/notifyAll()退出，之后需要再次获取对象的同步锁，才能进入就绪状态。
2. `join()`：等待插队的线程执行完毕，线程进入就绪状态。会释放插队线程对象的锁（`threadX.join()`，threadX这个线程对象的锁会被释放，而不是父线程所持有的对象锁[^3])。
3. 调用`LockSupport.park()`[^2]进入无限期等待状态；调用`LockSupport.unpark(Thread)`回到运行状态。

## 5、超时等待状态(TIEM_WAITING)

> 由于某种原因放弃了CPU的使用权，暂停运行，直到进入就绪状态，才有机会重新进入运行状态。

1. 有 Timeout 参数的 `join()`：不释放对象的同步锁，时间结束或等待插队的线程执行完毕，进入就绪状态。

2. 有 Timeout 参数的 `wait()`：时间结束或线程调用了`notify()/notifyAll()`后退出，之后需要再次获取对象的同步锁，才能进入就绪状态。

3. `sleep()`：不释放对象的同步锁，需要等待睡眠时间结束，才可以进入到就绪状态。

4. 调用`LockSupport.parkNanos()/parkUntil()`进入限期等待状态；调用`LockSupport.unpark(Thread)`回到运行状态。

## 6、终止状态(Terminated)

> 线程执行完毕，或产生异常退出了`run()`方法。

## 线程中断

```java
Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("正在执行");
                try {
                    while (!Thread.currentThread().isInterrupted()) {
                        System.out.println("休眠");
                        Thread.sleep(100);
                    }
                } catch (InterruptedException e) {
                    System.out.println(Thread.currentThread().getName() 
                                       + "(" + Thread.currentThread().getState() + ") 线程中断");
                }
            }
        }, "t1");

System.out.println(t1.getName() + "[start before] state：(" + t1.getState() + ")");
t1.start();
System.out.println(t1.getName() + "[start after] state：(" + t1.getState() + ")");

TimeUnit.MILLISECONDS.sleep(300);
System.out.println(t1.getName() + "[interrupt before] state：(" 
                   + t1.getState() + "),isInterrupted: (" + t1.isInterrupted() + ")");
t1.interrupt();
System.out.println(t1.getName() + "[interrupting] state：(" 
                   + t1.getState() + "), isInterrupted: (" + t1.isInterrupted() + ")");
TimeUnit.MILLISECONDS.sleep(300);
System.out.println(t1.getName() + "[interrupt after] state：(" 
                   + t1.getState() + "), isInterrupted: (" + t1.isInterrupted() + ")");
```

> t1[start before] state：(NEW)
> t1[start after] state：(RUNNABLE)
> 正在执行
> 休眠
> 休眠
> 休眠
> t1[interrupt before] state：(TIMED_WAITING), isInterrupted: (false)
> t1[interrupting] state：(TIMED_WAITING), isInterrupted: (true)
> t1(RUNNABLE) 线程中断
> t1[interrupt after] state：(TERMINATED), isInterrupted: (false)

通过调用`interrupt()`设置线程中断标识，由`isInterrupted()`查询线程的中断状态。

当线程处于`TIME_WAITING/WAITING`时，调用线程的`interrupted()`会抛出中断异常。

## 锁池&等待池

> 每个对象都有两个池，锁池(阻塞队列)和等待池(等待队列)。

- 锁池（Entry List）：假设线程A已经拥有了某个对象（注：不是类）的锁，若其它的线程想要调用这个对象的某个同步方法或者同步块，由于这些线程在进入对象的同步方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。
- 等待池（Wait Set）：假设线程A调用了某个对象的`wait()`，线程A就会释放该对象的锁（因为`wait()`必须出现在同步代码中，自然在执行`wait()`方法之前，线程A就已经拥有了该对象的锁），同时线程A就进入到了该对象的等待池中。线程B调用了相同对象的`notifyAll()`，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果线程B调用了相同对象的`notify()`，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池。

# 使用线程的方式

## 一、继承Thread类

```java
public class MyThread extends Thread {
    public void run() {
        //...
    }
}

public static void main (String args[]){
    MyThread t = new MyThread();
    t.start();
}
```

> 1.重写 run() 方法，该方法体就是线程需要完成的任务（线程执行体）
>
> 2.创建线程对象
>
> 3.启动线程

## 二、实现Runnable接口

```java
public class MyRunnable implements Runnable {
    public void run(){
        //...
    }
}

public static void main (String args[]){
    MyRunnable mr = new MyRunnable();
    Thread t = new Thread(mr);
    t.start();
    //或 new Thread (new MyRunnable()).start();
}
```

> 1.实现 Runable 接口的 run() 方法
>
> 2.将 Runnable 实现类对象作为参数，创建 Thread 对象
>
> 3.通过 Thread 对象调用 start()方法，启动线程

## 三、实现Callable接口

```java
public class MyCallable implements Callable {
    public Integer call(){
        //...
        return 123;
    }
}

public static void main (String args[]){
   MyCallable mc = new MyCallable();
   FutureTask ft = new FutureTask(mc);
   Thread t = new Thread(ft);
   t.start();
   system.out.print(ft.get());
}
```

> 与 Runnable 接口相比，Callable 接口可以有返回值，通过 FutrueTask 封装返回值
>
> 1.实现 Callable 接口的 call() 方法
>
> 2.使用 FutrueTask 类包装 Callable 实现类对象，将 call() 方法的返回值封装到FutrueTask 对象中
>
> 3.将 FutureTask 对象作为参数，创建 Thread 对象
>
> 4.通过 Thread 对象调用 start()方法，启动线程
>
> 5.通过 FutureTask 对象的 get() 方法，获取返回值

## 实现接口 VS 继承Thread

实现接口相比更好

1. Java 不支持多继承，继承 Thread 类后，无法在继承其他类；接口可以实现多个。
2. 多个线程可以共享同一个接口的实现类对象，开销比较小；但要访问当前线程，必须调用 Thread.currentThread()方法。

==创建线程的方式只有继承`Thread`类和实现`Runnable`接口两种，而使用线程的方式有以上几种方式。==

## start() & run()

new ⼀个 Thread，线程进⼊了新建状态，调⽤ `start()` ，会使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 `start()` 会执⾏线程的相应准备⼯作，然后⾃动执⾏ `run()` 的内容。

但是，直接执⾏ `run()` ，会当成⼀个 main 线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。

# 多线程协作

- `join()`：「Thread类方法」，子线程调用`join()`，就会抢占cpu执行任务，当任务完成或超时，才会继续执行父线程的任务。

- `wait()/notify()/notifyAll()`：`Object`方法；调用该对象的`wait()`方法，会将线程挂起，放入对象锁的等待队列中，等待其他线程调用该对象的`notify()或notifyAll()`方法唤醒线程；`notify()`方法时随机唤醒一个线程，`notifyAll()`方法时唤醒所有线程。都只能在同步方法或同步代码块中使用，否则会引起`IllegalMonitorStateException`异常。

- `wait()和sleep()方法的区别`

  > 1. `wait()`是`Object`的方法，`sleep()`是`Thread`类的静态方法。
  > 2. `wait()`会==释放锁==，`sleep()`不会。

# 线程间通信

线程之间通过对共享资源的互斥访问（加锁）实现通信。

实现方式有两种：`Synchronized、ReentrantLock`

读写锁：`Lock接口的ReadWriteLock`类：读共享，写排他。

```java
ReadWriteLock lock = new ReentrantReadWriteLock();
Lock readLock = lock.readLock();
Lock writeLock = lock.writeLock();
```

# 并发编程

## 并发安全

访问统计

```java
/**
 * 访问接口计数器
 */
public class AccessCount {
    /**
     * 访问次数
     */
    private Integer accessCount;
    
    public void access() {
        accessCount ++;
    } 
}
```

> 在单线程中，这部分代码可以保证访问接口计数，但多线程中却无法保证。
>
> accessCount ++ 在 Java 内存模型（JMM）中的过程如下：
>
> 1. 线程从主内存中 Copy accessCount=0 到工作内存；
> 2. 线程从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
> 3. 线程将 accessCount=1 刷新到主内存中。
>
> 在多线程竞争的情况下，可能会变为：
>
> 1. 线程1从主内存中 Copy accessCount=0 到工作内存；
> 2. 线程从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
> 3. 线程2从主内存中 Copy accessCount=0 到工作内存；
> 4. 线程2从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
> 5. 线程1、2无论先后顺序，将 accessCount=1 刷新到主内存中。
>
> 当线程1、2都运行结束，主内存中 accessCoun=1，而不是我们期望的2；这就是我们所说多线程访问共享变量所产生的线程安全问题。
>

## 并发编程的三大特性

### 原子性

对共享变量的多个操作是原子的，要么全部成功，要么全部失败，中途不会因为其他因素中断。

比如 accessCount ++ ，如果线程从主存读取、+1、写回主存这三个步骤是原子的，那么数据与预期一定是相符的。

### 可见性

一个线程对共享变量的修改对于其他线程是立马可见的。通过MESI（Modified Exclusive Shared Or Invalid 缓存一致性协议）来保证可见性，在Core0修改了数据v后，让Core1在使用v前，能得到v最新的修改值。

#### MESI

==MESI协议解决了CPU缓存层面的可见性问题==

MESI协议的缓存状态机

- M（修改, Modified）: 本地处理器已经修改的缓存行（脏行），缓存行内容与内存中不同，且此cache只有本地一个拷贝（专有）。
- E（专有, Exclusive）: 缓存行内容和内存中相同，且其它处理器都没有这行数据。
- S（共享, Shared）: 缓存行内容和内存中相同，有可能其它处理器也存在此缓存行的拷贝。
- I（无效, Invalid）: 缓存行失效, 不能使用。

每次修改v后，都同步修改值到其他缓存了v的Cache中；也可以只同步使用前的最后一次修改值。后者性能上更优，如何实现呢：

1. Core0修改v后，发送一个信号，将Core1缓存的v标记为失效，并将修改值写回内存。
2. Core0可能会多次修改v，每次修改都只发送一个信号（发信号时会锁住缓存间的总线），Core1缓存的v保持着失效标记。
3. Core1使用v前，发现缓存中的v已经失效了，得知v已经被修改了，于是重新从其他缓存或内存中加载v。

### 有序性

happen-before原则保证指令顺序执行。

#### 指令重排序

Java编译器和系统处理器为了提高性能，可能会对指令进行重排序

#### 重排序流程

![image-20220916152544851](/Users/murphy/Library/Application Support/typora-user-images/image-20220916152544851.png)

Java编译器重排序：（happen-before会禁止部分特殊的重排序）

​	编译器优化重排序：在不改变单线程语义的情况，对指令进行重排序。

处理器重排序：（Java编译器会跟据处理器重排序规则在生成指令时，在特定指令前后添加相应的内存屏障「CPU指令」，防止处理器重排序）

​	指令级并行重排序

​	内存系统重排序

==以上三种重排序在多线程情况下都可能出现并发安全问题。==

## happen-before原则

1. 对象终结规则：一个对象的初始化完成先于对象的`finalize()`。
2. 监视器锁规则：一个锁的unlock操作早于后续对该锁的lock操作
3. 程序顺序规则：一个线程内按代码的书写顺序执行。
4. 传递规则：如果A操作先于B操作，B操作先于C操作，那么A操作先于C操作。
5. 线程启动规则：一个线程的`start()`早于线程的任意操作。
6. 线程终结规则：一个线程的终结检测晚于线程的其它操作。
7. 线程中断规则：一个线程的`interrput()`早于线程被检测出中断。
8. volatile规则：对volatile变量的写操作早于它的其它操作。

## 解决并发安全问题

### 无锁方式

------

#### Volatile关键字

> 1. 防止指令重排。
> 2. 解决编译器层面的可见性；volatile声明的变量，只能在主存中读写，保证数据的更新是内存可见的，每个线程都可以获得最新的数据。
>    - 写操作后有`store`指令（将修改的数据刷新到主内存）：当线程修改了volatile变量时，立刻强制刷新到主存；若其他线程的工作内存中有包含变量的副本时，强制过期失效变量副本，不允许读和使用；
>    - 读操作前有`load`指令（必须从主内存读取新值）：其他线程在运行过程中需要读取变量时，需要从主存中重新读取。
> 3. 不保证原子性。非线程安全。

![](https://i.loli.net/2021/05/26/jY6PACquFDdTVJM.png)

##### 内存屏障（内存栅栏）

[参考文章](https://zhuanlan.zhihu.com/p/270269628)

CPU级别禁止指令排序，通过一组处理器指令、禁止屏障前后的指令顺序互换。

Store：将处理器缓存的数据刷新到内存中。
Load：将内存的数据拷贝到处理器的缓存中。

- LoadLoad Barriers（Load1 | Barrier | Load2）：该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作。
- StoreStore Barriers（Store1 | Barrier | Store2）：该屏障确保Store1立刻刷新数据到内存（使其对其他处理器可见）的操作先于Store2及其后所有存储指令的操作。
- LoadStore Barriers（Load1 | Barrier | Store2）：该屏障确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作
- StoreLoad Barriers（Store1 | Barrier | Load2）：该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后，才执行该屏障之后的内存访问指令

#### CAS（乐观锁）

> `V`：主内存中的值；`E`：期望值；`N`：新值。
>
> ```java
> V == E;
> E = N;
> ```
>
> `ABA`问题：
>
> 1. 基本类型数据，无影响。
> 2. 引用类型数据，加上版本号，在比较时连带版本号一起比较。

#### ThreadLocal

> ThreadLocal 对象的意义从字面就可以看出，为线程提供本地存放私有数据。

![image-20210518114120256](https://i.loli.net/2021/05/26/c4lbUJK9MqE6Cfk.png)

```JAVA
// ThreadLocal  类的 set() get() 方法
public void set(T value) {
	Thread t = Thread.currentThread(); 
  ThreadLocalMap map = getMap(t); 
  if (map != null) 
		map.set(this, value); 
  else
		createMap(t, value);
}

ThreadLocalMap getMap(Thread t) {
	return t.threadLocals;
}
```

> ThreadLocalMap 是 ThreadLocal 的静态内部类。
>
> Thread 类中有两个 ThreadLocalMap 变量。
>
> 也就是说，每个线程都有一个 ThreadLocalMap 用来存放线程私有的数据，`ThreadLocal.getMap(Thread t)`可以获取到线程的 ThreadLocalMap；
>
> ThreadLocalMap 的 Entry 对象是 ThreadLocal 对象和其对应 set() 的 Object 值。

`ThreadLocalMap 中使用的 Key 是 ThreadLocal 的弱引用，而 value 是强引用；`

`当 ThreadLocal 没有外部强引用时，GC后，会出现 Key 为 null 的 Entry，从而产生内存泄漏；`

`ThreadLocalMap 在实现 set()、get()、remove()  方法时，会清理掉 Key 为 null 的记录；`

`建议使用完 ThreadLocal 方法后，手动调用 remove()。`

### 有锁方式

#### Synchronized

> 底层是依赖于操作系统的`Mutex Lock`（互斥锁）实现的。操作底层加解锁，需要从用户态转换到内核态，比较耗时。
>
> 两个线程同时访问同步代码块时，一个线程进入同步代码块，另一个线程就必须等待。

> **可见性**：一个线程对临界资源的改变，对于其他线程是可见的；也就是线程在使用变量时，必须从主内存中读取。
>
> **原子性**：线程对临界资源的操作是原子的，不可拆分为更多的步骤。否则会造成数据不一致的问题。如`count++`。
>
> **可重入锁**：线程可以进入任意一个已获得锁的同步代码块；在一定程度上避免了死锁。
>
> > 1. 同步方法`m1()、m2()`是同一个对象锁，`m1()`方法中调用了`m2()`方法，线程调用`m1()`方法，表示已经获取到对象锁，当需要调用`m2()`方法时，不需要重新获取锁就可以调用。
>> 2. 子类重写了父类的同步方法`m()`，并在代码中调用了父类的`m()`[`super.m()`]，线程获取到子类的锁调用子类的`m()`，当执行`super.m()`时，可以直接拿到锁。**前提是锁的同一个对象或者`class`**。
> >
>> `PS`：`AQS`中维护了一个`state`，线程获取锁时，会将`state+1`，释放锁会`-1`,可重入锁可以在锁上加锁，想要彻底释放锁，`state-1==0`时其他线程才可以去申请这个锁。
> 

##### 使用

###### 一、对象加锁

> 对对象加锁，多个线程访问获取同一个对象锁是互斥的。

```java
public class MyLock {
    // 实例方法上使用，对对象加锁
    synchronized void methedA(){
        // todo some things
        ...
    }
    
    public static void main(String[] args) {
        // 在代码块上对对象加锁
        synchronized(this){
        	// todo some things
        	...
    	}
    } 
}
```

###### 二、类加锁

> 对类加锁，多个线程访问同一个类的锁是互斥的。

```java
public class MyLock {
    // 静态方法上使用，对类加锁
    synchronized static void methedA(){
        // todo some things
        ...
    }
    
    public static void main(String[] args) {
        // 在代码块上对类加锁
        synchronized(MyLock.class){
        	// todo some things
        	...
    	}
    } 
}
```

`PS：线程A调用一个实例对象的同步非静态方法，线程B调用这个实例对象的同步静态方法，是允许的，不会发生互斥，因为线程A访问的同步方法占用的是对象锁，而线程B访问的同步方法占用的是类锁。`

###### 三、双重检验锁实现单例

> 单例模式实现条件：
>
> 1. 私有化构造。
> 2. 公共静态方法提供实例。

```java
public class singleton {
    
	private volatile static Singleton instance;
    
	private singleton(){}
    
    public static singleton getInstance(){
        if(null == instance){
            synchronized(Singleton.class){
                if(null == instance){
                    instance = new singleton();
                }
            }
        }
        return instance;
    }
}
```

`线程获取对象实例时，需要先判断当前对象是否被创建，没有被创建就获取对象的类锁，再次校验有没有其他线程在当前线程获取锁前创建了对象，没有再创建对象。`

`此处volatile 的作用是防止在创建对象时JVM自动指令重排。`

`创建对象三个指令：`

1. `为instance开辟内存空间。`
2. `初始化对象。`
3. `将instance指向分配的内存地址`

如果线程A在获取对象时，JVM将指令重排序为1-3-2，指令2完成后，线程B获取对象判断对象不为空，直接使用该对象，此时对象还未初始化。



##### 原理

###### 一、同步代码块

> 通过`javap -c -s -v -l`查看字节码，可以看到，同步代码块有两个明显指令：`monitorenter`、`monitorexit`。
>
> `monitorenter`：进入同步代码块；线程尝试获取对象监视器 Monitor 的持有权。
>
> `monitorexit`：退出同步代码块；线程释放对象监视器 Monitor 的持有权。

###### 二、同步方法

> 通过 javap （javap -c -s -v -l）查看字节码，可以看到，JVM中通过标识 `ACC_SYNCHRONIZED` 状态，表明该方法为同步方法。

同步方法和同步代码块在指令集上的表现不同，但实质上都是获取对象监视器 Monitor 。

线程获取锁时，锁的计数器为0，表明锁可以被获取；

锁被获取后，锁的计数器会被置为1，表明锁已被占用；

线程释放锁后，锁的计数器会置为0，表明锁已被释放；

线程获取锁时，锁的计数器为1，线程会被阻塞，直到锁被其他线程释放，当前线程获取到锁为止。



##### 锁升级（Java 6）

==Java6 之后对 Synchronized 关键字做了优化，通过自旋锁、偏向锁、轻量级锁、锁消除、锁粗化等减少锁的开销。可升不可降，偏向锁可以被重置为无锁状态==

对象头中`MarkWord`信息

|      锁状态      | 是否偏向锁（1 bit） | 锁标志位（2 bit） |                             情景                             | 参数                                  |
| :--------------: | :-----------------: | :---------------: | :----------------------------------------------------------: | ------------------------------------- |
|       无锁       |          0          |        01         |                                                              |                                       |
|      偏向锁      |          1          |        01         |    大多数情下，锁一直由一个线程多次申请，降低申请锁的代价    | 关闭：`-XX:-UseBiasedLocking = false` |
| 轻量级锁(自旋锁) |                     |        00         | 竞争锁的线程数量较少，且线程持有锁的时间短，避免`CPU`从用户态转到内核态带来的开销 | -XX：+UseSpinning                     |
|     重量级锁     |                     |        10         | 自旋会消耗`CPU`，当自旋时间过长，如自旋次数达到`10`次，线程还是无法获取锁，升级为重量级锁 |                                       |

###### 偏向锁

**偏向锁的加锁**

- 偏向锁标志是未偏向状态（即0），使用 CAS 将 MarkWord 中的线程ID设置为自己的线程ID，
  - 如果成功，则获取偏向锁成功。
  - 如果失败，则进行锁升级。
- 偏向锁标志是已偏向状态
  - MarkWord 中的线程 ID 是自己的线程 ID，成功获取锁
  - MarkWord 中的线程 ID 不是自己的线程 ID，需要进行锁升级；偏向锁的锁升级需要进行偏向锁的撤销。

**偏向锁的撤销**

- 对象是不可偏向状态
  - 不需要撤销
- 对象是可偏向状态
  - MarkWord 中指向的线程不存活
    - 允许重偏向：退回到可偏向但未偏向的状态
    - 不允许重偏向：变为无锁状态
  - MarkWord 中的线程存活
    - 线程ID指向的线程仍然拥有锁
      - 升级为轻量级锁，将 MarkWord 复制到线程栈中
    - 不再拥有锁
      - 允许重偏向：退回到可偏向但未偏向的状态
      - 不允许重偏向：变为无锁状态

即撤销偏向的操作需要在全局检查点执行。我们假设线程A曾经拥有锁（不确定是否释放锁）， 线程B来竞争锁对象，如果当线程A不在拥有锁时或者死亡时，线程B直接去尝试获得锁（根据是否 允许重偏向（`rebiasing`），获得偏向锁或者轻量级锁）；如果线程A仍然拥有锁，那么锁 升级为轻量级锁，线程B自旋请求获得锁。

###### 轻量级锁

仅使用 CAS 进行操作，实现获取锁

**加锁**

- 线程尝试使用 `CAS` 将对象头中的 `Mark Word` 替换为指向锁记录（`Lock Record`）的指针。
  - 成功，当前线程获得轻量级锁。
  - 失败，虚拟机先检查当前对象头的 Mark Word 是否指向当前线程的栈帧
    - 指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块 执行操作。
    - 否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数达到界限值（`threshold`），轻量级锁将会膨胀为重量级锁。

**解锁**

- 如果对象的`Mark Word`仍然指向着线程的锁记录，使用CAS操作， 将`Dispalced Mark Word`替换到对象头
  - 如果成功，则表示没有竞争发生。
  - 如果失败， 表示当前锁存在锁竞争，锁就会膨胀为重量级锁。

###### 重量级锁

使用操作系统互斥量（mutex）来实现的传统锁。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入==堵塞状态==，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁。

##### 自适应自旋

自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。

- 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。
- 如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。

##### 锁粗化

扩⼤加锁范围，避免反复的加锁和解锁。

```java
for(int i = 0 ; i < 100 ; i++){
    synchronized(lock){
    }
}
//JVM 锁粗化
synchronized(lock){
    for(int i = 0 ; i < 100 ; i++){
    }
}
```

##### 锁消除

`JVM`在即时编译(`JIT`：当代码即将第一次运行时进行编译)时，去除不存在资源竞争的锁，节省无意义的请求锁时间。

例如：`StringBuffer的append()`是线程安全的，当我们只在线程内部将`StringBuffer`当做局部变量使用时，调用`append()`方法，不存在锁竞争的情况，会发生锁消除。

```java
// 同步代码块
public void m(){
    synchronozed(this){
    	do something;
	}
    synchronozed(T.class){
    	do something;
	}
}
// 同步方法 等价于 synchronozed(this)
public synchronozed void m2(){
    do something;
}
// 同步静态方法 等价于 synchronozed(T.class)
public synchronozed static void m2(){
    do something;
}
```

#### ReentrantLock

> 可重⼊锁 ReentrantLock 是 Lock 最常⻅的实现，Lock接⼝是 Java并发包的顶层接⼝。
>
> 底层通过`JDK`实现，会受到版本影响。通过`CAS`进行操作。
>
> 可重入锁、公平锁(默认非公平锁)、可尝试获取(`tryLock()`、可中断(`lockInterruptibly()`)。
>
> ⼀旦使⽤了公平锁，性能会下降。

#### synchronized & ReentrantLock

1. 可重⼊锁：⾃⼰可以再次获取⾃⼰的内部锁

   - ⽐如⼀个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重⼊的话，就会造成死锁。同⼀个线程每次获取锁，锁的计数器都⾃增1，所以要等到锁的计数器下降为0时才能释放锁。

2. `synchronized`依赖于`JVM`底层实现，没有暴露细节；

   `ReentrantLock`依赖于`API`；
   `ReentrantLock` 是`JDK`实现的（也就是`API`层⾯，需要`lock()`和`unlock()`⽅法配合`try/finally`语句块来完成）

3. `ReentrantLock`⽐`synchronized`增加了⼀些⾼级功能

   主要来说主要有三点

   1. 等待可中断；
   2. 可实现公平锁；
   3. 可实现选择性通知（锁可以绑定多个条件）;
      - `ReentrantLock`提供了⼀种能够中断等待锁的线程的机制，通过`lock.lockInterruptibly()`实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
      - `ReentrantLock`可以指定是公平锁还是⾮公平锁。⽽`synchronized`只能是⾮公平锁。所谓的公平锁就是先等待的线程先获得锁。 `ReentrantLock`默认情况是⾮公平的，可以通过`ReentrantLock`类的`ReentrantLock(boolean fair)`构造⽅法来制定是否是公平的。
      - `synchronized`关键字与`wait()`和`notify()/notifyAll()`⽅法相结合可以实现等待/通知机制，`ReentrantLock`类也可以实现，但是需要借助于`Condition`接⼝与`newCondition()`⽅法。`Condition`是`JDK1.5`之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能（也就是在⼀ 个`Lock`对象中可以创建多个`Condition`实例「即对象监视器」），线程对象可以注册在指定的`Condition`中，从⽽可以有选择性的进⾏线程通知，在调度线程上更加灵活。在使⽤`notify()/notifyAll()`⽅法进⾏通知时，被通知的线程是由`JVM`选择的，⽤`ReentrantLock`类结合`Condition`实例可以实现==选择性通知== ，这个功能⾮常重要，⽽且是`Condition`接⼝默认提供的。`synchronized`就相当于整个`Lock`对象中只有⼀个`Condition`实例，所有的线程都注册在它⼀个身上。如果执⾏`notifyAll()`⽅法的话就会通知所有处于等待状态的线程，这样会造成很⼤的效率问题，⽽`Condition`实例的`signalAll()`只会唤醒注册在该`Condition`实例中的所有等待线程。

### Synchronized & volatile

|          | Synchronized                     | volatile                         |
| -------- | -------------------------------- | -------------------------------- |
| 线程安全 | 安全，可见性、原子性             | 非安全，保证可见性，不保证原子性 |
| 性能     | 慢                               | 快                               |
| 作用域   | 代码块、方法                     | 变量                             |
| 意义     | 保证多线程间访问临界资源的同步性 | 保证多线程间访问玲姐资源的可见性 |

## JMM Java内存模型 (Java Memory Model)

> JVM定义了Java内存模型，屏蔽了不同操作系统与底层硬件之间访问的差异，实现各个平台统一的内存访问效果。
>
> 在Java当前的内存模型下，线程对数据的操作方式是：
>
> 1. 将数据从主存拷贝副本到本地内存；
> 2. 线程从本地内存获取数据；
> 3. 线程将修改后的数据写入本地内存；
> 4. 本地内存将数据刷新到主存中。
>
> 多线程的情况下，就可能产生数据不一致的问题；当线程A从主存读取数据`count=0`到工作内存，线程读取工作内存修改`count=count+1`，此时线程B从主存中获取数据`count=0`到工作内存，修改`count=count+1`，此时数据就会是脏数据。

![image-20210517172051328](https://i.loli.net/2021/05/17/5Rzxl8OySB9XkUN.png)

## 死锁

![image-20210512212016258](https://i.loli.net/2021/05/12/6SBVq2FKZiuE9xG.png)

> 多个线程同时被阻塞；
>
> 线程A持有资源2、线程B持有资源1，线程A需要申请资源1、线程B需要申请资源2，线程A、B都阻塞。

### 产生死锁的四个条件

1. 互斥条件：每个资源在任意时间只能由一个线程占用。
2. 请求和保持条件：一个线程/进程因请求资源而阻塞，对已获取的资源不释放。
3. 不剥夺条件：线程已获得的资源在未使用完之前，无法被其他线程强行剥夺，只能自己使用完后释放。
4. 循环等待条件：若干线程/进程间形成头尾相连的循环等待资源关系。

### 避免死锁的方式

> 根据产生死锁的四个条件，我们只要破坏其中一个条件即可避免死锁。

1. 互斥条件无法破坏，锁的存在本身就是为了让线程互斥访问临界资源。
2. 破坏请求和保持条件：一次性申请所有需要的锁。
3. 破坏不剥夺条件：占用部分资源的线程在申请其他资源被阻塞时，可以主动释放自己占用的资源。
4. 破坏循环等待条件：资源按序申请，如线程必须先获取资源A再获取资源B。

# 线程池

> 池化技术（线程池、数据库连接池、HTTP连接池）的思想：
>
> 1. 减少获取资源的消耗；
> 2. 提高资源的利用率。

## 线程池的优点

1. 降低资源消耗：通过重复利用已创建的线程，减少创建和销毁线程带来的消耗。
2. 提高响应速度：当任务到达，无需等待创建线程也能立即执行。
3. 统一管理、优化、监控。

## 自定义线程池

`《阿里开发规范手册》中建议使用 ThreadPoolExecutor 创建线程池，而不是Executors，原因是：`

1. `FixedThreadPool 和 SingleThreadExecutor：允许请求的队列⻓度为 Integer.MAX_VALUE，可能堆积⼤量的请求，从⽽导致 OOM。`
2. `CachedThreadPool 和 ScheduledThreadPool：允许创建的线程数量为 Integer.MAX_VALUE，可能会创建⼤量线程，从⽽导致 OOM。`

```java
/**
 * ⽤给定的初始参数创建⼀个新的ThreadPoolExecutor。 
 */
public ThreadPoolExecutor(int corePoolSize,
						  int maximumPoolSize, 
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue, 
                          ThreadFactory threadFactory, 
                          RejectedExecutionHandler handler
                         ) {
	if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0) 
        throw new IllegalArgumentException();
	if (workQueue == null || threadFactory == null || handler == null)
		throw new NullPointerException();
	this.corePoolSize = corePoolSize;
	this.maximumPoolSize = maximumPoolSize;
	this.workQueue = workQueue;
	this.keepAliveTime = unit.toNanos(keepAliveTime);
	this.threadFactory = threadFactory;
	this.handler = handler;
}
```

构造参数：

- corePoolSize：核心池的大小。
- maximumPoolSize：线程池的最大线程数量。
- keepAliveTime：线程空闲时间。
- workQueue：阻塞队列(任务缓存队列/任务等待队列)。
- handler：拒绝策略策略。

### Executors工具类提供的线程池类型

- FixedThreadPool ：  该⽅法返回⼀个固定线程数量的线程池。该线程池中的线程数量始终 不变。当有⼀个新的任务提交时，线程池中若有空闲线程，则⽴即执⾏。若没有，则新的任务会被暂存在⼀个任务队列中，待有线程空闲时，便处理在任务队列中的任务。 
- SingleThreadExecutor：  ⽅法返回⼀个只有⼀个线程的线程池。若多余⼀个任务被提交到该线程池，任务会被保存在⼀个任务队列中，待线程空闲，按先⼊先出的顺序执⾏队列中的任务。
- CachedThreadPool： 该⽅法返回⼀个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复⽤，则会优先使⽤可复⽤的线程。若所有线程均在⼯作，⼜有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执⾏完毕后， 将返回线程池进⾏复⽤。

## 线程池原理

![image-20210518152720184](https://i.loli.net/2021/05/18/wEbuiWIpO36naLB.png)

# AQS



# Atomic原子类



[^1]: 当前线程分配的CPU时间使用完，CPU会切换到其他线程执行，此时当前线程的状态即为挂起。
[^2]:[LockSupport](https://www.jianshu.com/p/f1f2cd289205)
[^3]:[join释放锁是哪个锁](https://blog.csdn.net/huanfeng_AI/article/details/107721863)