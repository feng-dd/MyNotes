# `MQ`
## 为什么引入`MQ`？
> - ***系统解耦：***解决不同多个应用间的依赖。有利于不同应用开发间的协同；一定程度上防止**一死全死**的问题。
> - ***削峰填谷：***通过`MQ`接收并存储请求，解决瞬时写压力过大导致系统崩溃等问题。
> - ***异步消息：***解决系统间一对多调用时导致响应过慢的问题。
> - ***蓄流压测：***通过`MQ`堆积一定量消息后再放开进行压测。
>

## 常见`MQ`之间的差别

![img](https://i.loli.net/2021/02/25/PvNLc6Obp5nHI9W.png)

## 引入`MQ`带来的缺点

> - 系统复杂度提升：当`MQ`出现问题时，会导致相关服务不可使用的问题。
> - 系统可用性降低：引入`MQ`可能会出现消息丢失、重复消费等问题，从而导致系统需要考虑更多的问题。
> - 数据一致性问题：当系统出现重复消费消息或消息丢失时，数据的一致性问题无法得到保障，需要一些机制来保障。

## 保证MQ的高可用

> **`Rabbit MQ`通过集群来保证其高可用**
>
> 1. 主备模式（warren）：只有主节点提供读写，从节点只做备份；当主节点宕机时，完成自动切换，从→主。该模式可以保证数据不丢失，但是存在单机瓶颈（并发、存储）。
> 2. 主从模式：主节点提供读写，从节点只读。该模式相对主备模式在并发的性能上有一定提升，但是存储方面并没有提升。
>
> 1. 普通集群模式：假设有两个节点`broker 1`、`broker 2`，每个节点都保存了`queue`的元数据，但是消息实体只存在于其中一个节点中（`product`写入到哪个节点）；如果`product`生产消息到`broker 1`，`consumer`从`broker 2`消费时，两个节点会临时进行消息传输，将消息实体从`broker 1`取出经`broker 2`发送给`consumer`。
>
>    该模式下，尽量让`consumer`与每个节点都进行连接（一个逻辑队列，要在多个节点建立物理队列），否则消费消息时，节点间传输数据会降低性能，产生系统瓶颈；当`broker 1`节点故障，`broker 2`无法获取到`broker 1`中未消费的消息，如果做了消息持久化，需要等待`broker 1`恢复，然后进行消费，如果未做消息持久化，就会产生消息丢失的问题。
>
> 2. `Mirror`镜像集群模式（常用）：把需要的队列做成`Mirror`镜像队列，主节点主动同步数据到从节点，使得数据存在于多个节点，当主节点宕机时，`Rabbit MQ`通过`HA proxy`（`HA`机制）自动进行主备节点切换，保证数据不丢失。
>
>    该模式解决了普通模式中的可靠性问题，不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。
>
> ![image-20210226162017592](https://i.loli.net/2021/02/26/X8PM5SZsRdekoph.png)
>
> **`kafka`通过分布式架构提升高可用**
>
> 写操作时，`product`会将数据写在`leader`上，当数据完全存放在`leader`本地磁盘后，其他`follow`会主动来pull数据。一旦`follow`同步好数据，会发送`ack`通知`leader`，`leader`收到就会返回*写成功*给`product`。
>
> 读的时候，只会从`leader`上读取，但只有消息已经被所有`follow`同步成功且返回`ack`后，消息才能被`consumer`读取到。
>
> 如果`consumer`或者`product`能对`follow`进行消息操作，系统复杂性变高，容易产生数据不一致性的问题，所以只能操作`leader`。
>
> ![img](https://i.loli.net/2021/02/26/wSP8zNZoB6lLA9n.png)

## 参考 

>[Rocketmq原理&最佳实践](https://www.jianshu.com/p/2838890f3284/)