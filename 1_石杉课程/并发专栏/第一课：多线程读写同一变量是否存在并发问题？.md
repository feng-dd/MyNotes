# 第一课：多线程读写同一变量是否存在并发问题？

## 案例

> 统计服务器接口被调用的次数

```java
/**
 * 访问接口计数器
 */
public class AccessCount {
    /**
     * 访问次数
     */
    private Integer accessCount;
    
    public void access() {
        accessCount ++;
    } 
}
```

上述代码可以实现单线程服务的接口的访问统计，但多线程下会存在问题吗？

答案是肯定的！但是原因呢？我们从系统及JVM层面去分析一下程序执行的过程！

## 内存模型

### 系统层面

> 从系统层面，CPU执行程序，数据存在主存中，CPU在运行程序的时候，需要从主存读取数据，运算后的结果要写回主存中。

![image-20210601115153098](https://i.loli.net/2021/06/01/XmuSTZL1di9r5lB.png)

`CPU运算速度相较于从主存读写的速度来说，快的不是一个量级，导致CPU的使用效率很低；`

`操作系统层面为此优化了执行过程，在每个CPU中加了一层高速缓存区；`

1. `数据会从主存Copy到高速缓存；`
2. `CPU从高速缓存区获取数据；`
3. `运算后写回到高速缓存区；`
4. `高速缓存区会刷新到主存中。`

![image-20210601134310668](https://i.loli.net/2021/06/01/RVbi6uL2KmPaIHx.png)

### Java内存模型（JMM）

> JVM定义了Java内存模型，屏蔽了不同操作系统与底层硬件之间访问的差异，实现各个平台统一的内存访问效果。

![image-20210601135222474](https://i.loli.net/2021/06/01/OIJnP4Nksfd6bXx.png)

`JVM启动后，系统会为JVM分配一定的内存空间(如图中的4G，可通过JVM参数配置)，这部分就是JVM的`*主内存*。

`Java程序是通过线程来运行的，每个线程都有自己私有的`*工作内存*，`线程会将数据从`*主内存*`Copy到`*工作内存*`中，再执行计算，之后，把运算的结果刷新到`*主内存*`中。`

## 分析

### 线程安全

> accessCount ++ 在Java内存模型中的过程如下：
>
> 1. 线程从主内存中 Copy accessCount=0 到工作内存；
> 2. 线程从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
> 3. 线程将 accessCount=1 刷新到主内存中。
>
> 在多线程竞争的情况下，可能会变为：
>
> 1. 线程1从主内存中 Copy accessCount=0 到工作内存；
> 2. 线程从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
> 3. 线程2从主内存中 Copy accessCount=0 到工作内存；
> 4. 线程2从工作内存获取 accessCount=0，并做 +1 操作，accessCount=1；
> 5. 线程1、2无论先后顺序，将 accessCount=1 刷新到主内存中。
>
> 当线程1、2都运行结束，主内存中 accessCoun=1，而不是我们期望的2；这就是我们所说多线程访问共享变量所产生的线程安全问题。

![image-20210601141022621](https://i.loli.net/2021/06/01/ajfLeTwGOvih1Fd.png)

![image-20210601141058449](https://i.loli.net/2021/06/01/YvDr3lK9pMGIsNb.png)

*两个红框的操作，无论线程1&2的先后顺序。*

`这种多线程访问同一个对象时，调用该对象方法得到不正确结果的问题，即为线程安全问题。`

### 如何解决

> 通过分析 accessCount ++ 的过程（上述的三个步骤），如果线程1在执行 accessCount ++ 时，线程2无法对 accessCount 进行读写操作，也就是accessCount ++的三个步骤是整体一次完成的，那么就可以得到正确的结果。
>
> 这就是我们所说的保证并发安全的一个关键因素：**原子性**；即一个或多个操作，要么全部执行并不被任何因素打断，要么就都不执行。
>
> 所以，如果保证 accessCount ++ 是原子性的，那么就可以得到正确的统计结果。