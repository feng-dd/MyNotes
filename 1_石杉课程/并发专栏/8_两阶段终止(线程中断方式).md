# 两阶段终止（Two-phase Termination）

> 既要保证线程灵活的切换运行状态，又要保证线程优雅的处理完当前任务。
>
> 1. 线程A发出信号，告知正在运行的线程B将被终止。
> 2. 接收到此信号的线程B，做完善后工作，停止运行。
>
> 在系统中，有时会因为网络问题，导致大量请求占用线程资源，而无法被释放的场景；如大量用户建立Socket连接看视频。

### 线程异常终止DEMO

```java
public class Two_phase_Termination_Demo {

    /**
     * 执行线程
     */
    private Thread executeThread;
    /**
     * 运行状态
     */
    private volatile boolean isRunning = false;

    /**
     *
     * @param task 发生阻塞的线程任务
     */
    public void execute(Runnable task) {
        executeThread = new Thread(() -> {
            Thread childThread = new Thread(task);

            // 子线程设置为守护线程
            childThread.setDaemon(true);
            childThread.start();
            try {
                // 强行执行子线程，使其进入休眠状态
                childThread.join();
                isRunning= true;
                System.out.println(isRunning);
            } catch (InterruptedException e) {
                //e.printStackTrace();
                System.out.println("异常捕获");
            }
        });
        executeThread.start();
    }

    /**
     *
     * @param mills 强制结束任务的时长阈值
     */
    public void shutdown(long mills) {
        long currentTime = System.currentTimeMillis();
        while (!isRunning) {
            // 任务是否超过1s
            if ((System.currentTimeMillis() - currentTime) >= mills) {
                System.out.println("任务超时，需要结束他!");
                executeThread.interrupt();
                break;
            }
        }
        isRunning = false;
    }
    
    public static void main(String[] args) {
        Two_phase_Termination_Demo executor = new Two_phase_Termination_Demo();
        long start = System.currentTimeMillis();
        executor.execute(() -> {
            try {
                // 执行任务的时长2000ms
                Thread.sleep(2000);
                // 执行任务的时长500ms
//                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        executor.shutdown(1000);
        System.out.println(executor.isRunning);
        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
```

```console
任务超时，需要结束他!
false
1289
异常捕获
```

![image-20210623205540378](https://i.loli.net/2021/06/23/SBIjUW9J6qCfbp3.png)

1. 执行 execute()，创建 executeThread 线程，并 start() 启动；
2. executeThread  线程开始执行，创建了 childThread 这个子线程，并start()启动；
3. executeThread  线程执行 childThread.join() 强行执行子线程；
4. 子线程睡眠 Thread.sleep(2000) ；
5. 主线程执行 shutdown()，isRunning = false 进入循环；
6. 进行系统时间判断，刚开始判断间隔时间很快，达不到设置的1s；但是 childThread 在休眠，executeThread 需要等待 childThread 执行完毕才能执行；
7. 在间隔时间大于设置的1s后，进入if判断中，设置 executeThread `中断标志`；
8. 此时 childThread 还在休眠，executeThread 因为 join() 处于等待状态，所以会抛出 InterruptedException ，executeThread 终止；
9. 由于 childThread 被设置为`守护线程`，当用户线程执行完毕后，无需等待守护线程执行完毕，只要JVM线程终止，守护线程也就终止了。

### 响应 interrupt() 调用而抛出异常的方法

![image-20210623210102628](https://i.loli.net/2021/06/23/v3b8erNxhFORcSG.png)

