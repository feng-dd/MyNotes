# 死锁场景：百万交易系统转账过程发生循环等待

> 账户A和账户B同时相互转账；
>
> 在高并发场景下，通常账户转账时需要先锁定自己的账户，再锁定对方账户，保证同一时间只有一个线程执行转账；
>
> 如果账户A、B都持有自己的锁，并尝试获取对方的锁，双方都无法申请到对方的锁，循环等待造成`死锁`。

![image-20210609162747343](https://i.loli.net/2021/06/09/TeucDCam4NjlqQA.png)![image-20210609162954740](https://i.loli.net/2021/06/09/FCewgcLrhW8jRO5.png)

## 死锁

![image-20210609161933599](https://i.loli.net/2021/06/09/tacKrW6knsAgb5L.png)

> 两个或两个以上的线程在执行过程中，互相持有对方所需要的资源，导致这些线程处于等待状态，无法继续执行。
>
> 若无外力作用，它们都将无法推进下去，就进入了“永久”阻塞的状态。

### 死锁代码

```java
public class deadlock.DeadLock {
    public static String obj1 = "obj1";
    public static String obj2 = "obj2";

    public static void main(String[] args) {
        Thread a = new Thread(new deadlock.Lock1());
        Thread b = new Thread(new deadlock.Lock2());
        a.start();
        b.start();
    }
}

public class deadlock.Lock1 implements Runnable {
    @Override
    public void run() {
        try {
            System.out.println("deadlock.Lock1 running");
            while (true) {
                synchronized (deadlock.DeadLock.obj1) {
                    System.out.println("deadlock.Lock1 lock obj1");
                    Thread.sleep(3000);
                    synchronized (deadlock.DeadLock.obj2) {
                        System.out.println("deadlock.Lock1 lock obj2");
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

public class deadlock.Lock2 implements Runnable {
    @Override
    public void run() {
        try {
            System.out.println("deadlock.Lock2 running");
            while (true) {
                synchronized (deadlock.DeadLock.obj2) {
                    System.out.println("deadlock.Lock2 lock obj2");
                    Thread.sleep(3000);
                    synchronized (deadlock.DeadLock.obj1) {
                        System.out.println("deadlock.Lock2 lock obj1");
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### 结果

```console
deadlock.Lock1 running
deadlock.Lock1 lock obj1
deadlock.Lock2 running
deadlock.Lock2 lock obj2
```

`并没有打印 deadlock.Lock1 lock obj2，和Lock1 lock obj2，线程发生死锁了。`

#### 分析

1. 线程1&2被创建，并启动；
2. 线程1获取到obj1这个锁，休眠3s；（无论线程1、2谁先运行都一样）
3. 线程2获取到obj2这个锁，休眠3s；
4. 线程1获取obj2这个锁失败，等待；
5. 线程2获取obj1这个锁失败，等待。

### 死锁产生的原因

> 死锁的发生必须具备以下四个必要条件：
>
> 1. 互斥：共享资源X、Y同一时刻只能被一个线程占用；
> 2. 占用且等待：线程占用共享资源X，等待其他线程占用的共享资源Y时，不会释放共享资源X；
> 3. 不可抢占：线程占用的共享资源不会被其他线程抢占；
> 4. 循环等待：线程A等待线程B占用的共享资源，同时线程B等待线程A占用的共享资源。

### 避免产生死锁的方法

> 遇到死锁时，没有什么好的办法处理，通常只能通过重启系统应用。
>
> 所以最好的解决方式是开发时避免死锁，只要破坏掉上述产生死锁的原因之一就可以。

#### 一、互斥

> 无法更改，这是使用锁的原因。

#### 二、占用且等待

> 一次性申请需要的所有资源；转账场景中线程一次性申请完账户A&账户B的锁。

```java

```



