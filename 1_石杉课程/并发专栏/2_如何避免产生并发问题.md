# 避免产生并发安全问题

> 并发安全问题就是多线程并发访问修改共享变量从而造成结果异常的问题。
>
> 解决的方式有两种：
>
> - 无锁
> - 有锁

![image-20210603113836175](https://i.loli.net/2021/06/03/FDKtwz8vHP61Ibo.png)

## 一、无锁方式

### 1、局部变量

> 局部变量是线程的私有变量，仅存在与线程的工作内存中，所以不会存在并发安全问题。

```java
public void count(){
    int i = 0;
    i++;
    System.out.print(i);
}
```

严格来说，局部变量不属于解决并发问题的范畴，因为局部变量不属于多线程中的临界资源，但是我们可以通过这种方式，在某些场景中的临界资源替换为局部变量，且不会影响业务逻辑。

### 2、不可变对象

> 不可变对象一旦创建，对象的状态就不可变，那么在并发场景中，也不会存在并发问题了。

```java
public final class NerverObj{
    private final Integer x;
    private final Integer y;
    
    public NerverObj(Integer x, Integer y){
        this.x = x;
        this.y = y;
    }
    
    // getXX()...
}
```

当NerverObj对象的属性需要变更时，直接替换为新的对象。

#### 原理

1. final 成员变量在使用前是一定被初始化过的。
2. private 成员变量防止子类或其他通过引用直接修改变量值。
3. 禁止提供修改成员变量的方法。
4. 进制类被继承后，子类通过自定义方法修改变量值。
5. 如果类有数组或集合类型的变量，在提供外部访问前需要做防御性复制。

此处引申一个知识点：Java传参是值传递还是引用传递。

答案是：值传递。

#### 值传递

##### 基本数据类型参数

> 传递的是参数值的副本，方法内修改了副本的值，但是不会影响原来的值。

##### 引用数据类型参数

> 传递的是引用的副本，方法外的引用和方法内的引用副本指向的是同一个对象，所以方法内修改了对象，方法外引用的对象也会变化。

### 3、ThreadLocal

> ThreadLocal类为所有线程存储了对应的对象，且这个对象只会被对应的线程处理。

![image-20210603140622335](https://i.loli.net/2021/06/03/YCzMFHXv2AVeloy.png)

#### 源码

> 每个线程中都有一个 ThreadLocalMap（Entry的key是这个公共的ThreadLocal<?>对象，value是当前线程的值）；
>
> ThreadLocal本质上就是在每个线程中都有自己的一个副本，每个线程的副本互不影响，没有任何关系，不存在所谓的"共享变量"，所以就不存在并发安全问题。

```java
public class Thread implements Runnable {
	ThreadLocal.ThreadLocalMap threadLocals = null;
}

public class ThreadLocal<T> {
    public void set(T value) {
       Thread t = Thread.currentThread(); 
        ThreadLocalMap map = getMap(t); 
        if (map != null) 
          map.set(this, value); 
        else
          createMap(t, value);
    }

    ThreadLocalMap getMap(Thread t) {
       return t.threadLocals;
    }
    
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
}
```

### 4、CAS

> Compare And Swap ：比较并置换；使用三个操作数，内存地址V，预期值A，修改后的值B，当线程从内存地址拿到的值V = 预期值V，就把内存地址的值V替换为修改后的值B。
>
> Atomic为前缀的原子类都实现了CAS操作。
>
> 保证并发性能的同时，也保证了线程安全。

```java
/**
 * 接口访问计数器
 */
private AtomicInteger accessCounter = new AtomicInteger(0);

public void atomicAdd(){
    counter.incrementAndGet();
}

// 源码
public class AtomicInteger extends Number implements java.io.Serializable {
	private static final Unsafe unsafe = Unsafe.getUnsafe();
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }
}
```

Java 通过 Unsafe类，Unsafe类的 compareAndSwapInt() 这个 native方法实现CAS操作，从而保证操作是原子的，从而避免并发问题。

![image-20210603170232748](https://i.loli.net/2021/06/03/eVNQOh3a2gzEB65.png)

**线程1**更新`accessCounter=1`后，**线程2**发现主存的`accessCounter=1`和预期值`accessCounter=0`不相等，无法成功更新`accessCounter=accessCounter+1`，

所以重新从主存读取`accessCounter=1`，主存的`accessCounter=1`和预期值`accessCounter=1`相等，**线程2**更新`accessCounter=2`成功。

#### ABA问题

