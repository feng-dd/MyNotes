# 使用Redis会对系统造成怎样的影响

> Redis 是一种NoSQL数据库，在系统中常作为缓存使用，也可以作为消息队列使用。

## 意义

> 系统引入Redis缓存中间件，可以给系统带来高性能，并支持高并发的场景。

### 高性能

查询客户相关信息（如：开卡信息、会员等级、是否消费过、账户余额）的请求，在系统中，我们一般需要请求多个服务，进行数据组装，需要多条SQL查询得到结果，耗时很久，如6、700ms，且这些数据大部分时间是不变的，但却十分影响性能。

系统如果引入Redis，我们可以在系统初始化时，将用户的这些数据放在缓存中，通过Hash数据类型存放，客户在查询信息时，响应很快，只需几ms到几十ms，大大提高了系统的性能。

### 高并发

在日活高峰期，每秒客户请求很多，请求MySQL的频率也很高，MySQL的并发能力很弱，有可能导致MySQL服务器报警甚至宕机。

系统如果引入Redis，可以将高频，热点数据存入Redis中，大部分请求的数据，可以通过Redis返回，剩下Redis不存在的数据，去MySQL服务器获取。

## 带来的问题

> 1. 缓存与数据库双写不一致；
> 2. 缓存雪崩、缓存穿透；
> 3. 缓存并发竞争。

### 1、缓存数据库的双写一致性

> 在项目中使用缓存+数据库配合读写，一般遵循 **Cache Aside Pattern（缓存备用模式）**；
>
> - 查询：先查询缓存，缓存未命中，查询数据库，插入缓存，返回响应。
> - 更新：先更新数据库，再删除缓存。
>

为什么是删除缓存而不是更新缓存呢？原因：**Lazy思想，在用到缓存时才去缓存。**

1. 缓存中的数据有时不是直接从数据库查出来的，而是通过数据库查到数据在进行计算得到的；当更新了表中的一个字段，需要查询多张表才能计算出要缓存的值，代价比较高；
2. 如果这条数据是修改频繁，但查询较少；每分钟修改100次，缓存就要计算&修改100次，但每小时只有一两次查询，更新缓存的代价很高；如果是删除缓存，那么每小时只会计算&插入两次缓存。

#### 一、如果删除缓存失败(讨论的是在没有事务的情况下)

##### 问题

`上述 Cache Aside Pattern 会造成数据不一致的情况。`

![image-20210602231605252](https://i.loli.net/2021/06/02/Lbh2mwKkB3UGaPf.png)

##### 解决方案

`先删除缓存，再更新数据库；`

删除缓存失败->不更新数据库 ，缓存与数据库都没变化。

删除缓存成功->更新数据库失败，数据库有值，缓存为空，查询走数据库且将值放入缓存，缓存=数据库。

#### 二、删除缓存之后，更新数据库之前，其他线程查询该数据

##### 问题

`查询请求先查缓存，没有，查询数据库是修改前的数据，插入缓存后，更新请求更新了数据库的数据为新值，此时缓存(旧)与数据库的值(新)不一致。`

##### 解决方案

**读写串行化**

单机服务器下的方案：，将请求的路由放入JVM内存队列中，如同一个商品ID的读写请求路由，放到`LinkedBlockQueue<request>`队列中，每个商品ID对应一个内存队列，每一个内存队列对应一个工作线程去处理。

优化：当请求来了

1. 如果是写请求，放入请求队列；
2. 如果是读请求，检查请求队列中有没有写请求；
3. 有写请求，将读请求放入请求队列；
4. 没有写请求，继续判断请求队列中有没有读请求；没有，就放入请求队列；有，则直接return。
5. 连续来的都是读请求，全部return，不放入请求队列；做自旋，查Redis，如果一定时间内没有查到，直接读库。

多机服务器下的方案：可以新建一个专门做读写请求队列的服务，让多套机器路由到这个内存队列中，实现方式不太合适。

![image-20210603221536222](https://i.loli.net/2021/06/03/DAX41aEmCtLFhSK.png)

建议使用redis作分布式锁，当有更新请求时加锁，设置过期时间，防止死锁。`加锁的方式都会影响并发性能。`

### 2、缓存雪崩

> 系统高峰期，Redis发生问题宕机，导致用户的请求直接落到数据库上，导致数据库报警宕机；此时如果没有其他手段处理，DBA重启服务器后，数据库瞬间被新的请求打死。

![image-20210602142150877](https://i.loli.net/2021/06/02/2TfLCPrJwHA1Sav.png)

#### 解决方案

- 事前：Redis高可用，主从架构+哨兵，Redis cluster，避免全盘崩溃。
- 事中：本地 ehcache 缓存+Hystrix 限流&降级，避免MySQL被打死。
- 事后：Redis持久化，保证重启，自动从磁盘快速恢复缓存数据。

> 用户发送查询请求，系统A收到，先查ehcache，再查Redis，都不存在，查询数据库，再将数据库的结果放入ehcache和Redis中；
>
> hystrix组件可以限制每秒的请求数量，未通过限流组件的请求，系统通过降级策略（空白页、友情提示、默认页面等）返回用户。



![image-20210602143118714](https://i.loli.net/2021/06/02/VcKtoXs73DUeg9M.png)

该方案可以保证：

- MySQL不会被请求瞬间打死；
- 保证一定数量的请求可以被处理；
- 未通过的请求对应的客户，多刷新几次，请求有可能会被处理。

### 3、缓存穿透

> 系统瞬间接收到大量无效的请求（如id为负数的数据），所有请求直接打到数据库上，导致数据库告警宕机。

![image-20210602154849840](https://i.loli.net/2021/06/02/bKzBlwI9ofCQURh.png)

#### 解决方案

当收到第一个无效请求时，给对应key写一个空值到Redis（如 set -99 UNKNOWN），设置一个过期时间；

下次有相同key过来查询，在缓存失效前，直接返回数据。

### 4、缓存击穿

> 一段时间内，热点数据的key被频繁访问，当key过期失效的瞬间，大量请求直接打到数据库，造成数据库告警宕机。

#### 解决方案

1. 热点key永不过期。
2. 通过Redis | Zookeeper 实现互斥锁，等待第一个请求构建好缓存，再释放锁，后续请求可以直接从缓存获取数据。

### 击穿&穿透

> 从字面意义理解：
>
> 击穿，有某个东西被破坏了，中间有东西；如门被撞破了。
>
> 穿透，从缝隙中穿过，中间没有东西；如从门缝溜走了。
>
> 这个门就是redis。

### 5、Redis并发问题

> - 多个客户端并发写一个key，命令顺序错了，数据就错了。
> - 多个客户端并发hGet()一个key，然后进行修改，再hSet()回去，顺序错了，数据就错了。

Redis CAS方案

通过Zookeeper实现分布式锁，确保同一时刻只有一个实例去操作这个key，其他实例不能读写。

![image-20210603225508980](https://i.loli.net/2021/06/03/3teSilIv5pwY8gU.png)

从MySQL读数据时，连带修改时间一块读出来，写入缓存时，同时保存这条树的修改时间；

每次将数据从MySQL读出来写到缓存时，判断这条数据得到修改时间比缓存现有的修改时间新，是的话，写入成功，否则失败。