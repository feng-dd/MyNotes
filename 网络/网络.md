## 网络模型

### OSI七层网络模型

![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDvc1cQLtBePFFQOsiaQ3ApFgN8IicnibD8dCkpHY7oo39xJKRmBdnIneFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### TCP/IP网络模型

![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD1L695M5TPE3h7HArdKSDcfD2SENIKpS5jUGHdicwlBo0vDpicktAAiaWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDvAjMBhhnjGMia5IIxiaf5yORyVDpNIaSJOnHIIdbLuVBqaJKupibIMfBQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> 应用层协议（端口）：
>
> ​	FTP（21）：文件传输协议。
>
> ​	SSH（22）：远程登录协议。
>
> ​	TELNET（23）：远程登录协议。
>
> ​	SMTP（25）：发送邮件协议。
>
> ​	POP3（110）：接收邮件协议。
>
> ​	HTTP（80）：超文本传输协议。
>
> ​	DNS（53）：域名解析服务，运行在UDP上。
>
> 传输层协议：TCP、UDP协议。
>
> 网络层协议：IP协议。
>
> 路由器在网络层，根据IP寻址；交换机在数据链路层，根据MAC地址寻址。

应用层只关心需要传递那些数据，数据交由传输层，类似于将商品交给快递。

传输层将应用层的数据整合为数据包，数据量很大时，还好将数据包分块，接收方的传输层则需要根据报文中的端口号，将数据包传送给对应的应用；

实际的传输功能是由网络层实现的，网络层负责将数据从一台设备传输到另一台设备，以IP协议为例，IPv4协议中，IP地址共32位，被分为4段，每段8位；IP协议主要有两个功能：寻址和路由；寻址是通过子网掩码计算出IP地址对应的网络号（IP地址所属的子网）和主机号（标识同一子网下的不同主机），找到对应的主机；路由则是通过算法决定最优的网络传输路径。

网络不止一个，所以大多数情况都需要跨网络传输，每台设备的网卡都有唯一的MAC地址，路由器通过ARP协议找到对应IP下的MAC地址，就能找到该设备；数据链路层就是为网络层提供链路级别传输。

物理层则是将数据包转换为电信号，让其在物理介质中传输，为数据链路层提供二进制传输服务。

## TCP & UDP

> TCP：面向连接的、可靠的、基于字节流的传输层通信协议。
>
> UDP：面向无连接的传输层通信协议。

### TCP头部格式

![image-20220830102109505](/Users/murphy/Library/Application Support/typora-user-images/image-20220830102109505.png)

> 序列号：建立连接时生成32位随机数，通过SYN包传输，每次发送数据会做累加运算，用于解决**网络包乱序**问题。
>
> 确认应答号：期望下次收到的数据包序列号，用于解决**丢包**问题。

### UDP & TCP 的区别

TCP和UDP都属于计算机网络协议中的传输层，负责传输`应用层`产生的数据。

UDP：支持发送大数据量，低延时的传输，但需要系统容忍数据丢失，一般用作视频、语音等。

TCP：基于字节流，支持错误重传机制、流量控制、拥塞控制、错误校验，确保连接稳定，数据完整。

| 协议特点 | TCP                                                          | UDP                                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接     | 先建立连接，再发送数据                                       | 无需建立连接，直接发送大量数据                               |
| 服务对象 | 一对一的两点服务                                             | 支持一对一、一对多、多对多的交互通信                         |
| 传输方式 | 流式传输，数据无边界，保证顺序和可靠                         | 数据包单独发送，有边界，可能丢包和乱序                       |
| 传输效率 | 较慢（拥塞控制、流量控制等）                                 | 快                                                           |
| 首部开销 | 20个字节或更长                                               | 8个字节                                                      |
| 数据分片 | 数据大小 > MSS（去除IP和TCP头部后，一个网络包所能容纳的TCP数据的最大长度） 就会在运输层分片，若中途丢失一个分片，只需传输丢失的这个分片数据 | 数据大小 > MTU（一个网络包的最大长度，以太网中一般是1500字节） 会在IP层分片，当中途丢失一个分片，在实现可靠传输的UDP就需要重传所有数据包 |
| 错误检查 | 会进行错误校验，并进行错误恢复（数据包校验、丢弃重复数据、重发、重排序） | 会错误检查，但会丢弃错误的数据包                             |
| 可靠性   | 通过数据包校验、失序重排、重复丢弃、超时重发、流量控制，应答机制（接收方收到数据会给发送方发送确认ACK），保证接收到所有发送方数据 | 不可靠，不保证数据的完整性                                   |
| 应用场景 | 需要可靠性数据交付：FTP文件传输、HTTP/HTTPS                  | 包总量较少的通信：DNS、SNMP；简单高效的通信：视频、音频等多媒体通信；广播通信 |

### TCP三次握手

![image-20210508143458887](https://i.loli.net/2021/05/11/WRgMDfFToprqjO1.png)

​	<!-- seq:随机生成的32位数字 --> 

​	<!-- ack:ack nowledge number 等于收到的 seq + 1 -->  

​	<!-- 服务器状态都是发送报文后变更的 -->

​	<!-- 第三次握手时，客户端发送的应答报文中就可以携带数据了 -->

#### 1、改为两次握手会怎样（第三次握手取消）

> 1. server 无法确认 client 是否收到第二次握手的报文，无法交换初始序列号（发送数据的序列号）。
> 2. server 可能会收到*失效的连接申请(由于网络问题，很久之前的第一次握手)*，导致 server 连接上 一个不会发数据的 client，从而浪费网络资源。

#### 2、改为四次握手会怎样（如四次挥手的场景）

> 没有必要，改为四次握手的话，原第二次握手需要拆为两次（ACK第二次、SYN第三次），原第三次握手变为第四次握手。三次握手相当于是四次握手的优化

#### 3、第三次握手的ACK未送达到server会怎样

> server：未收到ACK确认报文，会重发SYN+ACK，client 收到重新发送ACK，如果 server 重试五次仍未收到，进入CLOSED状态。
>
> client：
>
> 1. 在 server 重发过程中，client 向 server 发送 ACK报文，若 ack nowledge number 等于 sequence number+1，server 状态变更为 ESTABLISHED。
>
> 2. client 向 server 发送数据，server 是 CLOSED 状态，会以RTS包应答。
>
> <!-- RTS（Reset）包：有时主机需要尽快关闭连接（或连接超时，端口或主机不可达），都会发送RST包。-->
>
> <!-- 四次挥手会正常关闭TCP连接。-->

#### 4、建立连接后，客户端故障

> 正常连接的情况下，server 有一个计时器（2h），每收到一次 client 发送的数据，就会重置这个计时器。
>
> 客户端故障，client 不会发送数据给 server，计时器到达2h上限，server 会发送一个探测报文，后续每75s发送一次。
>
> 当连续10次 client 未响应，server 就认为 client 出现故障，继而断开连接。

### TCP四次挥手

![image-20201013142245984](https://i.loli.net/2021/01/28/LcAR2MldogJrCEX.png)

>  2MSL：MSL是报文在网络中的最大存活时间，2MSL两个最大报文存活时间。

#### 1、改为三次挥手会怎样（CLOSE_WAIT状态的意义）

> 被动方接收到主动方的FIN包，回复ACK包确认收到FIN，此时被动方可能存在需要发送给主动方的数据，所以需要等待这部分数据发送完毕，才会发送FIN包，停止数据发送。

#### 2、第二次挥手的ACK包丢失

> 主动方会再次发送FIN包

#### 3、TIME_WAIT的意义

> 第三次挥手，主动方接收到被动方的FIN包后，会回复ACK确认包。
>
> 为了防止主动方的ACK包由于网络等问题丢失，主动方会等待2MSL时间，用来等待被动方因为未收到ACK包而重发FIN包；
>
> 主动方收到FIN包会再次回复ACK包，再次等待2MSL时间，当2MSL时间内未收到FIN包时，主动方确认被动方已经接受到ACK包，此时主动方状态变为CLOSED。

Linux 可以通过 `netstat -napt`查看 TCP 状态

![image-20220830112117330](/Users/murphy/Library/Application Support/typora-user-images/image-20220830112117330.png)

### TCP重传机制

#### 超时重传

> 在发送数据时，设定了一个定时器，当超过指定时间未收到对方的ACK确认应答报文，就会重发该数据。

RTT：Round-Trip Time 往返时延，数据包的往返时间。

RTO：Retransmission Timeout 超时重传时间。

一般需要设置RTO略大于RTT；RTO过大，会导致重发慢，影响效率；RTO过小，会误判超时，导致过多重发，占用过多资源。

<!-- 超时重发的数据再次超时时，TCP的策略是超市间隔加倍 -->

#### 快速重传（Fast Retransmit）

> 当发送方收到三个相同的ACK报文时，会确认该ACK报文对应的数据包丢失，在定时器过期前会重传丢失的报文段。

#### SACK 方法（Selective Acknowledgment 选择性确认）

> 该方式需要在TCP头部的「选项」字段中添加了SACK，它可以将接收方缓存的地图（可以理解为数据的清单）返回给发送方，从而发送方可以只重传丢失的数据；是在出发了快速重传的情况下。

<!-- 双方的服务器均要支持SACK才行；Linux 2.4下默认开启，之前版本需要通过net.ipv4.tcp_sack 参数打开。-->

#### Duplicate SACK（D-SACK）

> 「接收方」使用SACK告诉「发送方」那些数据被重复接收了。
>
> 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
> 可以知道是不是「发送方」的数据包被网络延迟了;
> 可以知道网络中是不是把「发送方」的数据包给复制了;

<!-- 在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（Linux 2.4 后默认打开）。-->

### TCP滑动窗口

> 因为应答机制的存在，当数据包往返时间越长，通信效率就越低下，为此引入了窗口。
>
> 窗口：操作系统开辟了一个缓存空间，「发送方」在收到「接收方」的ACK报文前，缓存区保留已发送的数据，收到ACK报文后，才从缓存区移除。「发送方」根据窗口大小的上限内发送TCP段，窗口大小一般由「接收方」的缓存区大小决定

#### 「发送方」滑动窗口

![image-20220830164153887](/Users/murphy/Library/Application Support/typora-user-images/image-20220830164153887.png)

![image-20220830164211709](/Users/murphy/Library/Application Support/typora-user-images/image-20220830164211709.png)

![image-20220830164237831](/Users/murphy/Library/Application Support/typora-user-images/image-20220830164237831.png)

程序通过三个指针表示「发送方」窗口的四个部分

1. SND.WND：表示发送窗口的大小（大小是由接收方指定的）
2. SND.UNA：绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节
3. SND.NXT：绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。
4. 第三个指针：指向 #4 的第一个字节是个**相对指针**，= SND.UNA + SND.WND
5. 可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）

![image-20220830164104189](/Users/murphy/Library/Application Support/typora-user-images/image-20220830164104189.png)

#### 「接收方」滑动窗口

![image-20220830165249216](/Users/murphy/Library/Application Support/typora-user-images/image-20220830165249216.png)

1. RCV.WND：表示接收窗口的大小，它会通告给发送方。
2. RCV.NXT：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。
3. 指向 #4 的第一个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND 大小的偏移量，就可以指向 #4 的第一个字节了。

滑动窗口并不是一成不变的；当「接收方」的应用进程读取数据的速度快，接收窗口会空缺出来，接收窗口大小是通过 TCP 报文中的 Windows 字段来告诉「发送方」，传输过程是存在时延的，所以**接收窗口和发送窗口是约等于的关系**。

### TCP流量控制

> 防止「发送方」的数据填满「接收方」的缓存。
>
> 当「发送方」传输数据大于「接收方」接收和处理数据的速度时，「接收窗口」会逐渐收缩，最终可能为0，窗口关闭。
>
> 窗口收缩的情况大致有两种：
>
> 1. 上述情况
> 2. 「接收方」服务器繁忙，操作系统主动将缓存窗口收缩
>
> TCP每个链接都有一个持续定时器，当TCP连接的一方收到对方的零窗口通知，就回启动；当持续计时器超时，会发送窗口探测报文，对方接收后回应当前接收窗口大小，仍为0，会重置持续计时器；如果3次都是0的话，TCP会中断连接。

<!--糊涂窗口综合征：发送方通过Nagle算法策略来避免 -->

### TCP拥塞控制

> 通过拥塞窗口（cwnd）和慢启动门限（ssthresh）判断当前网络状况，根据不同状况选用不同算法：
>
> 慢启动、拥塞避免、拥塞发生、快速恢复

![](/Users/murphy/Library/Application Support/typora-user-images/image-20220830201159832.png)

#### TCP全连接队列和半链接队列

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accepet 队列；

服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。

<!-- 不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，内核会直接丢弃，或返回 RST 包。-->

### 抓包

tcpdump & wireshark

![image-20220830201516213](/Users/murphy/Library/Application Support/typora-user-images/image-20220830201516213.png)

![image-20220830201550837](/Users/murphy/Library/Application Support/typora-user-images/image-20220830201550837.png)

### TCP优化

> 重发`SYN `包的次数由`tcp_syn_retries` 参数控制，默认是 5 次。比如内网中通讯时，就可以适当调低重试次数，尽快把错误暴露给应用程序。
>
> `SYN+ACK` 重发次数的方法是，调整`tcp_synack_retries`参数，默认是 5 次。当网络繁忙、不稳定时，报文丢失就会变严重，此时应该调大重发次数。反之则可以调小重发次数。
>
> ![image-20201013163112889](https://i.loli.net/2021/01/28/ns47LjU2pDN6MAB.png)

## HTTP

`HTTP (HyperText Transfer Protocol)`：超文本传输协议。

### 概念

> 超文本指 `css、js、图片`等。
>
> HTTP协议属于应用层协议，基于TCP连接。
>
> HTTP协议用于客户端和服务器端之间的通信。
>
> HTTP协议是通过URL地址向web服务器发送请求。

### URI、URL、URN

URI：`Uniform Resource Identifier`，统一资源标识符。
URL：`Uniform Resource Locator`，统一资源定位符。
URN：`Uniform Resource Name`，统一资源名称。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/3aPj0GhFQDA0E6RyltX4BwamgouX7YPdg0zbGlb5Zibu4rYRia69KOscgj7fMPOib8g9avA6eApnr7zb7J9MgtYPQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_png/3aPj0GhFQDA0E6RyltX4BwamgouX7YPdYxfI9KZre2vMbzxUVDgkdG7nfribOGrV2B2J8Itmr8URdfEFjU0JrbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### HTTP特性

> 1. 简单：基本报文格式是 header + body，头部信息为key-value形式，易于理解。
> 2. 灵活易扩展：HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。
> 3. 无状态：服务器不记录HTTP的状态（不持久化），服务器可以节约资源；但有些操作是具有关联性的（如：登录-加购-下单-结算-支付），每次都需要确认身份信息。解决无状态问题的方法，最简单的方式是使用Cookie技术。
> 4. 不安全：明文传输（通过浏览器的F12或者抓包工具可以看到报文中的各种信息）；无身份验证（可能遭遇伪装，如假淘宝等）；无报文完整性检查（可能被篡改，如网页植入广告）。HTTPS协议就是HTTP协议引入SSL/TLS层，使得安全性的到了提升。
>

<!-- 短连接是HTTP1.0的主要缺点，每个TCP连接只能发送一个请求，处理完后连接就会关闭，如果还要请求就需要重新创建一个请求。HTTP1.1通过引入Cookie实现保持状态的功能，TCP连接默认不关闭（长连接），可以被多个请求复用，当一段时间内没有请求，就会自动关闭。一般web网站的服务是短连接；长链接一般用于操作频繁，点对点通讯且链接数不多的情况，如链接数据库。-->

<!-- HTTP/1.1在长连接的方式下可以实现管道网络传输，同个TCP连接里，第一个请求发出后，无需等待服务器响应，即可发送后续请求，减少响应时间。但有可能发生队头阻塞的性能问题（当客户端靠前的请求由于某些原因导致阻塞后，后续的请求都被阻塞）-->

![img](https://mmbiz.qpic.cn/mmbiz_png/3aPj0GhFQDA0E6RyltX4BwamgouX7YPdatpFZl7DfzNicJgbpz2TPaI7bcNInKVUUwjNYGtGGWn9vJJnzlBAKJQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_png/3aPj0GhFQDA0E6RyltX4BwamgouX7YPdehN2FicBmD6QwxjtWktCRpYI44gXk9PGsBBQeIJibvjflibQCibib0UChdA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> Cooike
>
> 当客户端向服务端发送请求时，服务端会给客户端发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 Set-Cookie：JSESSIONID=XXXXXXX 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 JSESSIONID=XXXXXXX 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；
>
> 接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样，你的浏览器才具有了记忆能力。

### 单点登录

![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDt4V7IRicwA7d9MIEdibHaxiaFBPaSKD2A3kuwxwM6micorkKJqiasj9AicaQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

>  使用 JWT 机制，它也是能够让你的浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点
>
> - JWT 的 Cookie 信息存储在`客户端`，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。
> - JWT 支持跨域认证，Cookies 只能用在`单个节点的域`或者它的`子域`中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过`多个节点`进行用户认证，也就是我们常说的`跨域认证`。

### 请求消息结构

![img](https://mmbiz.qpic.cn/mmbiz_png/3aPj0GhFQDA0E6RyltX4BwamgouX7YPdxknnx0ARphPxtxdHHibRCPyjYs3od2MePGDmbNfBMxUqYhfFX2dDXsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### 请求方法

> 1. GET：获取资源数据。
> 2. POST：提交资源数据。
> 3. HEAD：读取资源的元数据，获取报文首部。
> 4. PUT：传输文件，更新资源数据。HTTP1.1新增
> 5. DELETE：删除文件，删除资源数据，与PUT相反。HTTP1.1新增
> 6. OPTIONS：允许客户端查看服务器的性能。HTTP1.1新增
> 7. TRACE：回显服务器收到的请求，主要用于测试或诊断。HTTP1.1新增
> 8. CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。HTTP1.1新增
> 9. PATCH：是对 PUT 方法的补充，用来对已知资源进行局部更新 。HTTP1.1新增

### GET & POST

| 方法区别          | GET                                                          | POST                               |
| ----------------- | ------------------------------------------------------------ | ---------------------------------- |
| 作用              | 获取信息                                                     | 提交信息                           |
| 安全性            | 只读服务器资源，安全                                         | 不安全，会修改服务器上的资源       |
| 幂等性            | 保证                                                         | 非幂等，多次提交数据会创建多个资源 |
| 请求参数          | 请求参数拼写在URL后，由于URL长度有限制，导致请求参数长度受限 | 无限制                             |
| 缓存              | 浏览器主动cache                                              | 需手动设置                         |
| 数据包            | 发送请求会产生一个TCP数据包                                  | 发送请求会产生两个TCP数据包        |
| 回退/前进(浏览器) | 无风险                                                       | 会产生重复提交                     |

### 状态码

> 服务器通过状态码告诉客户端，当前请求的响应状态。
>
> 200：响应成功。
>
> 301：永久性重定向，表示请求的资源分配了新的URL。
>
> 302：临时性重定向。301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）。
>
> 400：表示请求报文中存在语法错误。
>
> 401：未经许可，需要通过HTTP认证。
>
> 403：服务器拒绝访问(访问权限问题)。
>
> 404：请求资源无法找到。
>
> 500：服务器内部错误，无法处理请求。
>
> 503：服务器超负荷或停机维护，无法处理请求。

![image-20220829165131612](/Users/murphy/Library/Application Support/typora-user-images/image-20220829165131612.png)

| 状态码 | 类别                          | 原因短语                           |
| ------ | ----------------------------- | ---------------------------------- |
| 1xx    | Informational（信息性状态码） | 接受的请求正在处理                 |
| 2xx    | Success（成功状态码）         | 请求正常处理完毕                   |
| 3xx    | Redirection（重定向）         | 需要进行附加操作以完成请求         |
| 4xx    | Client error（客户端错误）    | 客户端请求出错，服务器无法处理请求 |
| 5xx    | Server Error（服务器错误）    | 服务器处理请求出错                 |

### 工作原理

![image-20201012144156949](https://i.loli.net/2021/01/28/6fEmVe5KaYxqbc4.png)

### HTTP & HTTPS

![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyD19RoMWPIg8hv6BJZOaAle0qiclXjXBF4UUH9TWfjwmdibwP7EHssGqhA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> 区别
>
> 1. 浏览器地址栏的协议开头 `http://、https://`
> 2. 默认端口号`80、443`
> 3. HTTP + SSL/TLS = HTTPS
> 4. HTTP的消息体是明文的，HTTPS的消息体是加密和验证的。
> 5. HTTP建连相对简单，只需要进行TCP的三次握手后就可以进行数据传输，而HTTPS在TCP三次握手后，还需要进行SSL/TLS握手，才能进入加密报文传输。
> 6. HTTPS协议需要向CA（证书权威机构）申请数字证书，用于保证服务器身份是可信的。

![img](https://mmbiz.qpic.cn/mmbiz_png/libYRuvULTdUPX8o1HyXqaaxrG5kPIzyDjcdWBShTP9t0dVIW2OJ59LqE9uvhtcLjicrmxTaAG7bzdicDDzfmoR8g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

### session & cookie

> session：服务器端保持状态的方案。
>
> cookie：客户端保持状态的方案。
>
> cookie 保存在客户端本地，客户端请求服务器时，会将 cookie 一起提交；
>
> session 保存在服务端，通过检索 sessionId 查看状态。

## 访问网址到获取页面的流程

> 1. 浏览器从DNS服务器查找对应域名的IP地址。
> 2. 浏览器客户端与对应IP的服务器三次握手建立连接。
> 3. TCP/IP连接建立后，浏览器向服务器发送HTTP请求。
> 4. 服务器接收请求根据路径参数映射到相应的处理器处理，并将结果返回给浏览器。
> 5. 浏览器解析并渲染视图，如果有静态资源（js文件、css文件、 图片）的引用，则重复上述步骤向服务器请求资源。
> 6. 浏览器渲染数据和资源展现给用户。

## Socket

![image-20220830150302847](/Users/murphy/Library/Application Support/typora-user-images/image-20220830150302847.png)

> - 服务端和客户端初始化 `socket`，得到文件描述符；
> - 服务端调用 `bind`，将绑定在 IP 地址和端口;
> - 服务端调用 `listen`，进行监听；
> - 服务端调用 `accept`，等待客户端连接；
> - 客户端调用 `connect`，向服务器端的地址和端口发起连接请求；
> - 服务端 `accept` 返回用于传输的 `socket` 的文件描述符；
> - 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；
> - 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据的时候，就会读取到了 `EOF`，待处理完数据后，服务端调用 `close`，表示连接关闭。
>
> 这里需要注意的是，服务端调用 `accept` 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。
>
> 所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。
>
> 成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。

#### 输入网址到网页显示的过程中发生了什么？

当在浏览器输入URL访问时，实际是对服务器资源的请求；

1. 「浏览器」会解析URL，确定Web服务器和文件名，生成**HTTP请求消息**。
2. 通过「DNS域名服务器」获取Web服务器的**IP地址**，
   - 「浏览器」根据自己的TCP/IP配置的「本地DNS服务器」地址向其发送DNS请求，获取URL中Web服务器的IP地址。
   - 「本地DNS服务器」收到请求后，从自己的缓存中查找是否有对应的记录；若有，直接返回；若无，则会询问「根DNS服务器」；
   - 「根DNS服务器」会根据Web服务器域名的后置是`.com`，将`.com`对应的「顶级域名服务器」地址返回给「本地DNS服务器」。
   - 「本地DNS服务器」请求「顶级域名服务器」，「顶级域名服务器」会将负责Web服务器域名的「权威DNS服务器」地址返回。
   - 「本地DNS服务器」请求「权威DNS服务器」，「权威DNS服务器」将Web服务器域名对应的IP地址返回。
3. 获得了IP地址后，「浏览器」需要委托「操作系统」将消息发送给Web服务器。
   - 「浏览器」调用`Scoket`库委托协议栈工作。
   - 协议栈上半部分，UDP或TCP协议负责收发应用层数据。
     - 假如进行TCP可靠传输
     - 需要先进行**TCP三次握手**建立连接，才能进行*数据包*的传输。
   - 协议栈下半部分，IP协议对数据包进行分包（分为一个个的网络包）发送。
     - 网络包包含了MAC头部『接收方MAC地址和发送方MAC地址和协议类型（IP协议或ARP协议）』、IP头部『源IP地址（客户端输出的IP）和目标IP地址（由DNS域名服务器解析）』、TCP头部和HTTP报文。
     - TCP数据包需要在IP层封装为网络包发送给对方。
4. 网络包封装好之后，需要「网卡」将网络包从**数字信息转换为电信号**，通过网线传输到「交换机」。
5. 「交换机」根据MAC地址表查找到对应的MAC地址然后将信号发送到相应端口。
   - 若客户端与服务器不属于同一子网，「交换机」会将数据包转发给「路由器」，「路由器」通过路由表查询转发目标，再由相应的端口发送到目标的响应的端口，
   - 若同属一个子网，则直接发送到响应端口。
6. 最终「服务器」收到网络包后，会一层一层进行拆解和检查，最后传送给对应的HTTP进程进行处理。
7. HTTP进程收到请求后，发现是请求的是自己的页面，于是将这个页面封装到HTTP报文里，然后就和客户端步骤一样，一步步封装为网络包后，传递到客户端的「浏览器」。
8. 「浏览器」就把页面展示出来，最后需要断开连接，于是进行了TCP四次挥手结束。

### 工作中可能遇到的问题

我自己工作中就深刻体会到了它们多重要性，我最近项目就遇到 TCP 比较底层的问题：

​	我们的一个 Web 服务运行久之后，就无法与客户端正常建立连接了，使用 tcpdump 抓包发现 TCP 三次握手过程中，服务端把客户端握手过程中最后 1 个 ack 给丢掉了。

​	刚开始觉得非常的莫名奇妙，后面想起自己看过一篇 TCP 半连接和全连接队列的文章，就往这个方向排查问题，于是执行 netstat -s 命令查看 TCP error 相关的信息，发现 TCP 全连接队列溢出了，接着再通过 ss -lnt 命令进一步确认，当前 TCP 全连接队列确实超过了 TCP 全连接队列最大值，这个问题就很快定位出来了。

​	当 TCP 全连接队列溢出后，由于 tcp_abort_on_overflow 内核参数默认为 0，所以服务端会丢掉客户端发过来的 ack，如果你把该参数设置为 1，那现象将变成，服务端会给客户端发送 RST 报文，废弃掉连接。

​	那要扩大全连接队列也不难，TCP 全连接队列最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)，其中 somaxconn 是内核参数，而 backlog 是我们程序 listen 方法中指定的参数。
