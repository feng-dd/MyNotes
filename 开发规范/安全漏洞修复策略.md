# 常见安全漏洞整理及对策推荐

### 常见的安全漏洞(推荐处理方案)

#### 1，SQL注入

**定义：**

SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编程时的疏忽，通过SQL语句，实现无帐号登录，甚至篡改数据库。

基本注入思路与原理:

1.寻找到SQL注入的位置(定位可以自己组合sql参数的地址)

2.判断服务器类型和后台数据库类型

3.针对不同的服务器和数据库特点进行SQL注入攻击



**对策：** 

**1）****预编译语句** **PreparedStatement**

使用好处：

(1).代码的可读性和可维护性.

(2).PreparedStatement尽最大可能提高性能.

(3).最重要的一点是极大地提高了安全性.

 

原理：

sql注入只对sql语句的准备(编译)过程有破坏作用，而PreparedStatement在准备阶段只是把输入串作为数据处理，不再对sql语句进行解析，因此也就避免了sql注入问题。



**2）** **过滤传入的参数**

对传入的参数做过滤,

1.字符串可以比较 

2.其他参数可以正则表达式比较 

原理：

 对传入的数据做过滤



 **规范:**

老接口:使用了sql拼接的地方,做sql过滤,若老接口有重构计划,采用新接口的标准

新接口:不再使用 sql字符串拼接,采用PreparedStatement

 

#### 2，XSS漏洞

**定义：**

跨站脚本攻击XSS(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。

恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页面时，嵌入Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。

XSS分为：存储型 、反射型 、DOM型XSS

存储型XSS：存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie。

反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。反射型XSS大多数是用来盗取用户的Cookie信息。

DOM型XSS：不经过后端，DOM-XSS漏洞是基于文档对象模型(Document Objeet Model,DOM)的一种漏洞，DOM-XSS是通过url传入参数去控制触发的，其实也属于反射型XSS。



**对策**：

1、对重要的Cookie字段使用HTTPonly参数,并设置为ture。

2、检查所有用户可控输入。对所有的输入点进行严格的检查，过滤或拦截所有不符合当前语境的输入。(后端通用，但是不同的语境有不同的过滤规则，效果较差，还可能造成其他问题)  

3、检查所有外部用户输入的输出点（前端、后管）。因为XSS最终攻击是发生在输出点，因此需要分析出用户输入数据的所有输出点的环境，是输入在HTML标签中，还是HTML属性、script标签、事件CSS位置中，针对不同的输出位置，制定不同的转义或过滤规则。

4、处理富文本。在文章、论坛等需要用到富文本的地方，需要特别注意富文本与XSS的区分，严格禁止所有的危险标签及"事件"，原则上应当使用白名单过滤标签、事件及属性。(富文本过滤规则需要单独处理过滤)



**规范:**

**结论:任何地方都不能将用户输入的文本内容直接输出到HTML中** 

(推荐)富文本在所有输入和输出点统一采用自定义的转义或过滤；非富文本在所有输出点做转义或过滤



#### 3，XXE漏洞

**定义：**

XXE全名"xml external entity injection"即"xml外部实体注入"。

有了XML实体，关键字"SYSTEM"会令XML解析器从URI中读取内容，并允许它在XML文档中被替换。因此，攻击者可以通过实体将他自定义的值发送给应用程序，然后让应用程序去呈现。 简单来说，攻击者强制XML解析器去访问攻击者指定的资源内容（可能是系统上本地文件亦或是远程系统上的文件）。

攻击者通过xml语句中写入指定的xml实体语句，从而让服务器执行，从而导致问题。服务端接收和解析了用户端传过来的xml数据，而没有做安全控制，从而导致xml外部实体注入.



**危害：**

1：读取任意文件 

2：执行系统命令

3：攻击内外网站 

4：拒绝服务



**处理：**

1.使用开发语言禁用外部实体类解析

2.过滤XML

3.升级解析工具jar包，因为不少工具已经默认禁用外部实体了(但是有些不再维护了).



规范:

禁用外部实体类解析



## 用例补充:



### SQL用例:

为了便于理解,这里补充一些实际用例

#### 使用预编译语句



```sql
//以常用的框架mybatis为例,使用预编译语句
  SELECT * FROM score
  WHERE state = ‘ACTIVE’
    AND id = #{id}

//反例:1.直接代码拼接
  SELECT * FROM score
  WHERE state = ‘ACTIVE’
    AND id = 133
//反例:2.随意使用$符
       SELECT * FROM score
  WHERE state = ‘ACTIVE’
    AND id = ${id}

上面语句中的#标志很重要
```

解释:

#### 区别

1、#{ }是预编译处理，MyBatis在处理#{ }时，它会将sql中的#{ }替换为？，然后调用PreparedStatement的set方法来赋值，传入字符串后，会在值两边加上单引号；

2、${ }是字符串替换， MyBatis在处理${ }时,它会将sql中的${ }替换为变量的值，传入的数据不会加两边加上单引号。

注意：使用${ }会导致sql注入，不利于系统的安全性！

SQL注入：就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。常见的有匿名登录（在登录框输入恶意的字符串）、借助异常获取数据库信息等

应用场合：

1、#{ }：主要用户获取DAO中的参数数据,在映射文件的SQL语句中出现#{}表达式,底层会创建预编译的SQL；

2、${ }:主要用于获取配置文件数据,DAO接口中的参数信息,当$出现在映射文件的SQL语句中时创建的不是预编译的SQL,而是字符串的拼接,有可能会导致SQL注入问题.所以一般使用$接收dao参数时,这些参数一般是字段名,表名等,例如order by ${column}。



#### 过滤

如果由于业务中已含有过多的拼接sql,导致不得不选择过滤,那么选择合适的过滤内容至关重要,既不能影响业务又要过滤sql关键命令



```java
    /**
     * 添加sql关键字的参数校验
     * @param str
     */
    public static boolean sqlValidate(String str) {
        str = str.toLowerCase();//统一转为小写
        String badStr = "select|update|and|or|delete|insert|truncate|char|into|substr|ascii|declare|exec|count|master|into|drop|execute|table";
        String[] badStrs = badStr.split("|");
        for (int i = 0; i < badStrs.length; i++) {
            //循环检测，判断在请求参数当中是否包含SQL关键字
            if (str.indexOf(badStrs[i]) >= 0) {
                return true;
            }
        }
        return false;
    }
```



评价:如果不涉及英语语境下的业务,那么过滤还勉强可行,一旦涉及英语环境下的业务,选择过滤就会很不合适,例如and和or如果过滤,势必很容易影响业务.







### XSS漏洞:



#### 前端输入转义



```js
//使用“\”对特殊字符进行转义，除数字字母之外，小于127使用16进制“\xHH”的方式进行编码，大于用unicode（非常严格模式）。
var JavaScriptEncode = function(str){

    var hex=new Array('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f');

    function changeTo16Hex(charCode){
        return "\\x" + charCode.charCodeAt(0).toString(16);
    }

    function encodeCharx(original) {

        var found = true;
        var thecharchar = original.charAt(0);
        var thechar = original.charCodeAt(0);
        switch(thecharchar) {
            case '\n': return "\\n"; break; //newline
            case '\r': return "\\r"; break; //Carriage return
            case '\'': return "\\'"; break;
            case '"': return "\\\""; break;
            case '\&': return "\\&"; break;
            case '\\': return "\\\\"; break;
            case '\t': return "\\t"; break;
            case '\b': return "\\b"; break;
            case '\f': return "\\f"; break;
            case '/': return "\\x2F"; break;
            case '<': return "\\x3C"; break;
            case '>': return "\\x3E"; break;
            default:
                found=false;
                break;
        }
        if(!found){
            if(thechar > 47 && thechar < 58){ //数字
                return original;
            }

            if(thechar > 64 && thechar < 91){ //大写字母
                return original;
            }

            if(thechar > 96 && thechar < 123){ //小写字母
                return original;
            }

            if(thechar>127) { //大于127用unicode
                var c = thechar;
                var a4 = c%16;
                c = Math.floor(c/16);
                var a3 = c%16;
                c = Math.floor(c/16);
                var a2 = c%16;
                c = Math.floor(c/16);
                var a1 = c%16;
                return "\\u"+hex[a1]+hex[a2]+hex[a3]+hex[a4]+"";
            }
            else {
                return changeTo16Hex(original);
            }

        }
    }

    var preescape = str;
    var escaped = "";
    var i=0;
    for(i=0; i < preescape.length; i++){
        escaped = escaped + encodeCharx(preescape.charAt(i));
    }
    return escaped;
}


// 转义html
var HtmlEncode = function(str){
    var hex = new Array('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f');
    var preescape = str;
    var escaped = "";
    for(var i = 0; i < preescape.length; i++){
        var p = preescape.charAt(i);
        escaped = escaped + escapeCharx(p);
    }

    return escaped;

    function escapeCharx(original){
        var found=true;
        var thechar=original.charCodeAt(0);
        switch(thechar) {
            case 10: return "<br/>"; break; //newline
            case 32: return "&nbsp;"; break; //space
            case 34:return "&quot;"; break; //"
            case 38:return "&amp;"; break; //&
            case 39:return "&#x27;"; break; //'
            case 47:return "&#x2F;"; break; // /
            case 60:return "&lt;"; break; //<
            case 62:return "&gt;"; break; //>
            case 198:return "&AElig;"; break;
            case 193:return "&Aacute;"; break;
            case 194:return "&Acirc;"; break;
            case 192:return "&Agrave;"; break;
            case 197:return "&Aring;"; break;
            case 195:return "&Atilde;"; break;
            case 196:return "&Auml;"; break;
            case 199:return "&Ccedil;"; break;
            case 208:return "&ETH;"; break;
            case 201:return "&Eacute;"; break;
            case 202:return "&Ecirc;"; break;
            case 200:return "&Egrave;"; break;
            case 203:return "&Euml;"; break;
            case 205:return "&Iacute;"; break;
            case 206:return "&Icirc;"; break;
            case 204:return "&Igrave;"; break;
            case 207:return "&Iuml;"; break;
            case 209:return "&Ntilde;"; break;
            case 211:return "&Oacute;"; break;
            case 212:return "&Ocirc;"; break;
            case 210:return "&Ograve;"; break;
            case 216:return "&Oslash;"; break;
            case 213:return "&Otilde;"; break;
            case 214:return "&Ouml;"; break;
            case 222:return "&THORN;"; break;
            case 218:return "&Uacute;"; break;
            case 219:return "&Ucirc;"; break;
            case 217:return "&Ugrave;"; break;
            case 220:return "&Uuml;"; break;
            case 221:return "&Yacute;"; break;
            case 225:return "&aacute;"; break;
            case 226:return "&acirc;"; break;
            case 230:return "&aelig;"; break;
            case 224:return "&agrave;"; break;
            case 229:return "&aring;"; break;
            case 227:return "&atilde;"; break;
            case 228:return "&auml;"; break;
            case 231:return "&ccedil;"; break;
            case 233:return "&eacute;"; break;
            case 234:return "&ecirc;"; break;
            case 232:return "&egrave;"; break;
            case 240:return "&eth;"; break;
            case 235:return "&euml;"; break;
            case 237:return "&iacute;"; break;
            case 238:return "&icirc;"; break;
            case 236:return "&igrave;"; break;
            case 239:return "&iuml;"; break;
            case 241:return "&ntilde;"; break;
            case 243:return "&oacute;"; break;
            case 244:return "&ocirc;"; break;
            case 242:return "&ograve;"; break;
            case 248:return "&oslash;"; break;
            case 245:return "&otilde;"; break;
            case 246:return "&ouml;"; break;
            case 223:return "&szlig;"; break;
            case 254:return "&thorn;"; break;
            case 250:return "&uacute;"; break;
            case 251:return "&ucirc;"; break;
            case 249:return "&ugrave;"; break;
            case 252:return "&uuml;"; break;
            case 253:return "&yacute;"; break;
            case 255:return "&yuml;"; break;
            case 162:return "&cent;"; break;
            case '\r': break;
            default:
                found=false;
                break;
        }
        if(!found){
            if(thechar>127) {
                var c=thechar;
                var a4=c%16;
                c=Math.floor(c/16);
                var a3=c%16;
                c=Math.floor(c/16);
                var a2=c%16;
                c=Math.floor(c/16);
                var a1=c%16;
                return "&#x"+hex[a1]+hex[a2]+hex[a3]+hex[a4]+";";
            }
            else{
                return original;
            }
        }
    }
}
//直接调用htmlEncode方法即可
htmlEncode()
```

前端输出转义,同上类似.



#### 前端输出转义和过滤

前端输出转义和过滤(过滤js脚本和非法字符,以及一些破坏html页面的标签),富文本为例



```js
//以 Ueditor(百度开源的前端富文本框架)为例

//前端接受后端内容
    function getDataWithXss(){
        $.ajax({
            type: "GET",
            url: "getXssData",
            success: function(msg){
                console.log("后端输入的内容:"+msg);
                UE.getEditor('editor').execCommand('insertHtml', msg);
            }
        });
    }
    
//后端返回内容
"xss脚本: 1. <marquee><script>alert('xss')</script></marquee>   2. <style>@import'javascript:alert(\\\"xss\\\")';</style>  正常内容:  1.<<  2. <a  href=\\\"https://www.baidu.com\\\">test baidu</a>    3.>>>"

//前端转义过滤的内容
<p>
    xss脚本: 1.2.
</p>
<div></div>
<p>
    正常内容: &nbsp;1.&lt;&lt; &nbsp;2. <a href="\&quot;https://www.baidu.com\&quot;">test baidu</a> &nbsp; &nbsp;3.&gt;&gt;&gt;
</p>
```



### XXE漏洞:

#### 升级解析

根据对应的解析器去寻找官方文档,然后进行版本的选择和升级

#### 禁用外部实体

每个语言有自己的实现方式,这里仅仅展示java



```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setValidating(validate);
        factory.setNamespaceAware(true);

        //全面的封禁,一旦有外部实体,就会报错
         factory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        factory.setAttribute("http://xml.org/sax/features/validation", validate);
        factory.setAttribute("http://apache.org/xml/features/validation/schema", validate);
        factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
        factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
        //选择后面两个则是不启用外部解析

//需要注意的点:
一定要在new出新的解析器之前,设置好解析规则:也就是先setFeature,后new出解析器
DocumentBuilder builder = factory.newDocumentBuilder();
```