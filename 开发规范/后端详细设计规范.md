### 一、应用层书写要求 

**总体要求：**需要完全根据概要设计的规划，在对应的应用服务模块中的指定领域中进行书写。



1. 接口描述：接口功能的简要概述，包括入参出参及其描述、请求方式、可选项与必填项等

2. EO-Linker地址：该接口对应的EO-Linker地址

3. 时序图：用于描画当前REST接口的内部逻辑实现，以及对各中心、外部服务、以及Redis，Mq等的交互操作和交互方式。（要求统一采用语雀原生PlantUML语言书写）

4. 流程图（可选）：在无法使用时序图完全表达清楚实现逻辑的情况下，可以使用流程图来说明业务逻辑的实现流程，处理的先后顺序等。



**示例时序图：**

![image-20210414214408385](https://i.loli.net/2021/04/14/osEDjHCkVP7IvrS.png)



### 二、能力中心书写要求

**总体要求：**需要完全按照概要设计中对于能力服务的规划，在对应的能力中心的对应子领域中进行编写。



1. RPC接口描述：需要包含接口描述，入参出参及其描述、可选项与必填项，以及对应需要追加的注解。

2. 时序图：用于描画当前RPC接口的内部逻辑实现，以及对各中心、外部服务、以及Redis，Mq等的交互操作和交互方式。（要求统一采用语雀原生PlantUML语言书写）

3. 流程图（可选）：在无法使用时序图完全表达清楚实现逻辑的情况下，可以使用流程图来说明业务逻辑的实现流程，处理的先后顺序等。

4. 类图：用于表达业务逻辑的内部实现逻辑，包含从用户的客观世界模型中抽象出来的类、类的集合、类的内部结构、类的属性、以及类与类之间的关系。

5. E-R图：用于表达数据库表之间的关联关系。

6. 数据字典：用于表达各数据库中字段的详细定义，以及对应的枚举定义，索引设计等



### 三、ACM配置（统一文档收集）

每一个项目涉及到的ACM配置，以及使用场景说明都需要详细记载（另外，涉及到敏感的账密信息需要Mark）。

```properties
dataid：yundt.application.trade.iba.info
content：
{
"iba_action_url":"https://test.nuskin.com/commissions/api/v1/distributor-actions/",
"iba_client_id":"a262d0889ca44c378ad43aa95d603da3",
"iba_client_secret":"80c20a31f530499fA8D854F5668E3B69",
"iba_authorization":"Basic Q2hpbmFfU09BOmNoaW5hNG5vdw=="
}
```



### 四、MQ定义（统一文档收集）

1）Group、Topic、Tag，有序无序等需要写清楚

2）生产者和消费者需要写清楚

3）消费者的内部逻辑（如果已经在能力中心描述清楚，此处可以略），需要包含幂等校验方式，乱序处理方式，异常的处理方式 等。



### 五、Job设计（统一文档收集）

1）执行时间和频率需要写清楚（包括edas配置）

2）Job内部处理逻辑（如果已经在能力中心描述清楚，此处可以略）



### 六、Redis设计（统一文档收集）

1）Key-Value的详细描述，使用场景、特别是Value的数据接口的说明

2）过期时间、刷新机制的说明



### 补充：类图的画法

实现类图：在*UML*类图中，常见的有以下几种关系*:*泛化（*Generalization*）*,* 实现（*Realization*）*,*关联（*Association）,*聚合（*Aggregation*）*,组合(Composition)，依赖(Dependency)。我们使用最多的有三个，****组合\****，****泛化和实现。\***

可见性都是一样的，**"-"表示private、"+"表示public、"#"表示protected**。



#### **组合（Composition）**

【组合关系】：是整体与部分的关系.,没有公司就不存在部门   组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期

【代码体现】：成员变量

【箭头及指向】：带实心菱形的实线，菱形指向整体

表示的是一种整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也不存在，整体对象和成员对象之间具有同生共死的关系。在UML中组合关系用带实心菱形的直线表示。

比如人的头（Head）和嘴巴（Mouth）、鼻子（Nose），嘴巴和鼻子是头的组成部分之一，一旦头没了，嘴巴也没了，因此头和嘴巴、鼻子是组合关系，Java表示为：

```java
public class Mouth
{

}

public class Nose
{

}

public class Head
{
    private Mouth mouth;
    private Nose nose;
    
    public Head()
    {
        mouth = new Mouth();
        nose = new Nose();
    }
    
    public void shake()
    {
        
    }
}
```



代码实现组合关系，通常在**整体类的构造方法中直接实例化成员类**，这是因为组合关系的整体和部分是共生关系，如果通过外部注入，那么即使整体不存在，那么部分还是存在的，这就相当于变成了一种聚合关系了。

![image](https://i.loli.net/2021/04/14/orBFugCt97chbMH.png)





#### **泛化（Generalization）**

【泛化关系】：是一种继承关系,它指定了子类如何特化父类的所有特征和行为例如：老虎是动物的一种.

【箭头指向】：带三角箭头的实线，箭头指向父类

用于描述父子类之间的关系，父类又称为基类或者超类，子类又称作派生类。在UML中，泛化关系用带空心三角形的**实线**来表示。

比方说我想实现一个链表（Link），插入（insert）与删除（remove）动作我想让子类去实现，链表本身只实现统计链表中元素个数的动作（count），然后有一个子类单向链表（OneWayLink）去实现父类没有实现的动作，Java代码为：

```java
public abstract class Link
{
    public abstract void insert();
    public abstract void remove();
    
    public int count()
    {
        return 0;
    }
}


public class OneWayLink extends Link
{
    public void insert()
    {
        
    }

    public void remove()
    {
        
    }
}
```



UML的画法为：

![image](https://i.loli.net/2021/04/14/QNJZG2kVPxTa3qd.png)

在UML中，抽象类无论类名还是抽象方法名，都以**斜体**的方式表示，因为这也是一种继承关系，所以子类与父类通过带空心三角形的实线来联系。



#### **实现（Realization）**

【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现

【箭头指向】：带三角箭头的虚线，箭头指向接口

在接口中通常没有属性，而且所有的操作都是抽象的，只有操作的声明没有操作的实现。UML中用与类类似的方法表示接口，假设我有一个Animal：

```java
public interface Animal 
{
    public void move();
    public void eat();
}

public class Dog implements Animal 
{
    public void move() 
    {
        
    }

    public void eat() 
    {
        
    }
}

public class Cat implements Animal 
{
    public void move() 
    {
        
    }

    public void eat() 
    {
        
    }
}
```

此时应当使用带空心三角形的**虚线**来表示，UML应该是这样的：


![image](https://i.loli.net/2021/04/14/Y2sR1veFrLzxCtc.png)

两个抽象方法，Dog和Cat的实现将不一样，当然，在Dog和Cat之中，也可以增加Dog和Cat自己的变量和方法。