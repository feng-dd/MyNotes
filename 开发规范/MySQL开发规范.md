# RDS开发规范 V1.0

## 一、基础规范
【强制】：禁止在线上做数据库压力测试。
【强制】：禁止从测试、开发环境直连生产数据库。
【强制】：禁止开发直接修改数据库结构，所有修改都应整理成脚本。
【推荐】：不在数据库中存储图、文件等大数据，可通过文件存储服务（如OSS )保存原始内容，数据库中保留对应的链接或标记。
【推荐】：数据库仅提供内网访问地址，不提供公网访问地址。
【推荐】：使用MySQL 5.6或以上版本（支持在线DDL )。

## 二、运维规范
【强制】：所有环境，必须开启慢查询日志，以定位有问题的SQL。
【强制】：服务器默认字符集统一使用UTF8mb4。
【推荐】：不同环境根据具体情况设置，最大并发连接数（max_connections)。
 最大并发数计算公式：sum (应用/中心DB连接池中最大连接数 * 实例数量 ）。
 @Tyrion Cai(u76296) 帮忙确认下，这个公式中的[应用]和[中心DB]分别指什么？

> 注意：此数值并非越大越好，需要综合考虑数据库所在服务器支持的CPU/IO/内存，对已经投产的系统可用show variables like 'max_used_connections’ ；查看历史最大连接数，当此参数值接近 max_connections 时适当调整max_connections 的大小。

> 分布 式系统中，在数据库有读写分离的场景下，单台ECS的最大连接数设置应该为：数据库RDS的单个实例的最大连接数 / 所有连接到该RDS上的ECS实例个数。
> 注：像DRDS读写实例最大连接数不一样时，取读写实例中较小的最大连接数 / ECS实例个数。 

## 三、命名规范
【强制】：库名、表名、字段名统一使用英文小写字母、并采用下划线分割、尽量不超过32字符，且最多64字符。
【强制】：库名、表名、字段名禁止使用MYSQL保留字。
【强制】：库名、表名、字段名禁止使用数字开头，禁止两个下划线中间只出现数字。
【推荐】：库名与应用名称尽量一致，如有需要可加上环境的前缀。
     正例：xx项目用户中心生产库库名：prod_xx_center_user 。
【强制】：表名不使用复数名词，保留单数形式即可。
【推荐】：临时库、表名以tmp为前缀，并以日期为后缀。
【推荐】：备份库、表名以bak+日期为后缀。
     正例：us_user表的备份表 us_user_bak20190417。
【推荐】：表的命名最好是加上"业务缩写_业务名称_表的作用"。
     正例：tr_trade_config交易中心交易配置表 。

## 四、库、表、字段开发设计规范库规范
【强制】：使InnoDB存储引擎。
     InnoDB从5.5.8开始为默认引擎，并且提供了事务支持。
【强制】：字符集默认使用UTF8mb4。

> MySQL的UTF-8所能支持的最大字符长度为三个字节，能够支持的最大编码的 Unicode 字符是 0xFFFF，也就是 Unicode 中的基本多文平面（BMP）。任何不在基本多文平面的 Unicode字符（一般四个字节），都无法使用MySQL原有的 utf8 字符集存储。最常见的就是Emoji 表情，和一些不常用的汉字，以及任何新增的 Unicode 字符等等。
> MySQL的utf8mb4的编码是UTF-8标准（RFC 3629 )的完整支持（mb4即4-Byte UTF-8 Unicode Encoding），是专门用来兼容四字节的unicode。同时utf8mb4为utf8的超集并兼容utf8。

### 1. 表规范
【推荐】：单表行数超过500万行或者单表容量超过2GB ,才推荐进行分库分表。
  如预计三年后的数据量根本达不到这个级别，或者可以定时归档清理，请不要在创建表时就分库分。
【强制】：单条记录大小禁止超过8K ,如果超过此大小，需要将不常用的大字段分拆到关联表
【推荐】：==关联表和主表推荐优先使用业务主键关联而非数据库id主键。==
  业务主键是指除id外能唯一对应表记录的一个字段或多个字段的组合，如sku表的全局sku代码。
【建议】: 进行分库分表设计时，分库/分表数量主要考虑单表的数据容量，将单表的记录量控制在百万级。
【推荐】：分表的数量为2的N次方，比较容易跟拆分键hash处理后匹配。

### 2. 字段规范
【强制】：多表中的相同列，必须保证列定义一致（即名称，代码，类型，长度一致)。
【建议】:  将大字段、访问极低的字段拆分到单独的表中存储，分离冷热数据。
【建议】:  根据业务需要设计，不使用预留字段。MySQL5.6起已支持在线DDL ,不用增加字段锁表问题。
【强制】：禁止使用float、double类型，使用decimal存储精确浮点数。
【强制】：禁止使用text、ntext、image, blob类型。上述属于已经被淘汰的数据类型
-->原因：Text最大长度太长，不适合做索引，存储的内容太大，导致频繁进行磁盘IO，传输时导致网络延时，严重影响数据库性能。
【强制】：禁止使用enum,使用 tinyint来代替。
【强制】：禁止使用null字段,所有字段均定义为 NOT NULL。
  ==null字段很难查询优化,null字段的索引需要额外空间,null字段复合索引无效。==
【强制】：禁止预留过长空间给 varchar字段，varchar字段长度设计须根据业务实际需要进行长度控制。
  反例: status使用 varchar(128)进行存储。
【强制】：禁止在数据库中存储明文密码,需要把密码加密后存储,一般使用附加盐值后MD5摘要的做法。
【强制】：证件号,身份账号,银行卡号等敏感信息可逆加密后再存储,读取时通过业务逻辑解密,推荐使用AES算法进行加密处理。
【推荐】：加密存儲的字段,加密算法中增加版本标记,应对算法升级要求。
【推荐】：越简单越好:将字符转化为数字、使用 tinyint来代替enum类型。
【推荐】：使用 unsigned存储非负整数。
【推荐】：使用 datetime存储吋间,如涉及多时区使用,则存入时统一使用UTC时间,在业务层进行转换。
【推荐】：使用char(10),以yyyy-MM-dd格式存储日期。

### 3. 索引规范
【推荐】：单张表中索引数量不超过5个,多个单列索引,根据业务要考虑索引合并。
【强制】：单个索引中的字段数不超过5个。
【强制】：Inno DB每个索引都会加上主键,联合索引不需加上主键, innodb会自动加。
【强制】：重要的SQL必须被索引。
 比如:为了 UPDATE DELETE语句的预先准备的查询 WHERE条件列, ORDER BY、 GROUP BY、DISTINCT、ON的字段
【建议】：索引列比较长的,需要截取可变量部分,独立列存储并作为索引。譬如手机号,末尾6位作为索引列。（**※ 如果是utf8mb4字符集的，整体索引列长度建议为191Byte以下**）
【推荐】：一般不建议面向用户的逻辑中使用多表JOIN查询。
 如需使用多表JoIN的字段注意以下:

- 区分度最大的字段放在前面。
- SQL优先考虑覆盖索引。
- 避免冗余和重复索引。
- 索引要综合评估数据密度和分布以及考虑查询和更新比例。
- ==Join的字段需要考虑字符集是否一样：如果字符集不一致，相关索引会失效。==

【强制】：不在低基数列(可能的值集中在数量很小的集合)上建立索引,例如"性别"。由于区分度不高MySQL在具体执行时仍迸行全表扫描,不走索引。可以去掉对应索引,或跟其他区分度高的列建立组合索引低基数即离散度低
判断离散程度的方法是:
select count( distinct字段1) count( distinct字段2) from tablename越大越离散索引效果越好。
【强制】：==不在索引列进行数学运算和函数运算。过滤条件的值如果需要计算,对应的索引将失效。==
【强制】：==禁止使用外键,对父表和子表的操作会相互影响,降低可用性。参照完整性的保护可在业务端实现。==
【推荐】：==尽量不使用唯一索引(分库分表情况下唯一索引会失效)。==
 如需使用,索引中应包含 tenant id和dr,并且业务逻辑自兼容同业务记录的重复删除问题。
 反例：为保证登录名的唯一性,在账号表以登录名+dr作为唯一索引进行限制,由此导致以下问题
1）账号表如果进行分库分表,唯一索引的限制很大几率失效
2）相同的登录名第二次删除时可能违背唯一索引
3）如果是多租户场景,唯一索引没有租户id,不同租户之间也不得不保证用户名唯一
【强制】：索引命名:索引名称必须全部小写。
a）非唯索引必须以“idx_字段1_字段2”命名。
b）唯一索引必须以”uniq_字段1_字段2”命名。
【推荐】：==索引字段定义为 not null并设置 default值。NULL非常影响索引的查询效率。==
【推荐】：如需重复进行多条件查询,需要针对查询条件建立复合索引。复合索引从左到右的字段顺序考虑因素依次为:査询中必然出现的字段>记录区分度最高的字段。
正例：商品査询业务一般需要使用3个字段条件:商品名称,所属分组和dr,其中所属分组 和dr为必传条件,故建立的复合索引的为(所属分组,dr,商品名称),原因:必然出现的字段中所属分组的区分度高于dr;商品名称虽然区分度最高,但作为非必传参数,优先级低于dr。
【强制】：研发过程对多条件及复杂SQL要经常使用 explain进行性能分析，==避免出现using filesort造成性能问题。==

### 4. SQL规范
【强制】：SQL关键字全部是大写，每个词只允许有一个空格。
【推荐】：SQL语句尽可能简单，大的SQL想办法拆成小的SQL语句 可充分利用QUERY CACHE和充分利用多核CPU。
【推荐】：程序里建议合理使用分页来提高效率。
【强制】：LIMIT分页注意效率，OFFSET较大时要配合子查询使用，建议使用主键偏移非分页偏移。
  反例：SELECT id FROM t LIMIT 10000,10; -- 假设id是一个单步自增序列。
  正例： SELECT id FROM t WHER id > 10000 limit 10; -- 假设id是一个单步自增序列。
【强制】：==数据更新必须使用二级索引先查询出主键，再根据主键进行数据更新，未经架构师审批，不允许批量更新或删除。==
【建议】：排序、去重建议放到程序中做 （ps：涉及到分页的排序。最好是使用整形索引键排序）。
【推荐】：使用GROUP BY 分组、自动排序。
【建议】：注意使用性能分析工具: Sql explain / showprofile / mysqlsla。
【强制】：使用预编译语句，有如下好处：只传参数，比传递SQL语句更高效；一次解析，多次使用；降低SQL注入概率。
【强制】：按照一定的次序来访问表。如果先锁住表A，再锁住表B，那么在所有的过程中都要按照这个顺序来锁定它们，这样能降低死锁的发生。
【强制】：单表一到两年内数据量超过500W或数据容量超过2G考虑分表，且需要提前考虑历史数据迁移或应用自行删除历史数据。
【强制】：插入数据时， 需要显式指定插入的字段。
  正例：统一使用 INSERT INTO table_name (col1，col2，……) VALUES(?，?，…...)
  反例：使用默认字段 INSERT INTO table_name VALUES(?，?，…...)
【强制】：不要使用count(列名)或count(常量)来替代count(*)，count(*)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。 
说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。 
【强制】：count(distinct col) 计算该列除NULL之外的不重复行数，注意count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。 
【强制】：当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。 
正例：可以使用如下方式来避免sum的NPE问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; 
【强制】：使用ISNULL()来判断是否为NULL值。 
说明：NULL与任何值的直接比较都为NULL。 
1） NULL<>NULL的返回结果是NULL，而不是false。 
2） NULL=NULL的返回结果是NULL，而不是true。 
3） NULL<>1的返回结果是NULL，而不是true。 
【强制】：在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。 
【建议】：TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。 
说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 

### 5. 禁止使用
【强制】：禁止显示或隐式的类型转换反例： SELECT id FROM table WHERE id='1' ，id一般是bigint类型， 这个SQL就进行了隐式转换。
反例：在WHERE子句中numeric 型和int型的列相比较， 这也属于隐式转换。
【强制】：禁止使用不同类型的列进行等值查询。
【强制】：禁止在WHERE子句中的“=”左边表达式进行函数、算术运算或其他表达式运算。
【强制】：禁止使用前缀为%的LIKE
【强制】：==使用负向查询，如NOT， !=， <>， !>， 1<， NOT EXISTS， NOT IN以及NOT LIKE 比如 NOT IN会把空和NULL给查出来。==
【强制】：禁止在数据库中跑大查询，容易造成数据库不可用，严重影响业务；相关查询可考虑数据仓库或数据中台实现。
【强制】：禁止单条SQL语句同时更新多个表，每个SQL只能更新一个表。
【强制】：禁止使用跨库查询 ； 跨表查询需要经过技术架构师的审批。
【强制】：禁止核心业务流程的SQL出现情况：计算操作、多表关联、表遍历CASE WHEN等复杂查询，建议拆分成单表简单查询，通过程序进行关联。

### 6. 避免使用
【推荐】：避免大事务 事务要简单，整个事务的时间长度不要太长。 拆分复杂SQL为多个小SQL，避免大事务。
【强制】：业务逻辑中禁止使用：触发器、函数、存储过程、视图； 仅数据迁移的中间过程可酌情考虑使用。
【强制】：避免在数据库中进数学运算 MySQL不擅长数学运算和逻辑判断。
【推荐】：避免取出大字段且无用的内容 SELECT只获取必要的字段，尽量少使用SELECT *
【推荐】：==避免使用大表的JOIN。==
【推荐】：避免一个事务中更新太多数据 对数据的更新要打散后批量更新。
【推荐】：OLTP场景禁止子查询， OLAP场景尽量避免使用子查询，建议将子查询转换成关联查询 。     
 但由于子查询不使用索引，在关联查询也不使用索引的情况下，子查询是要优于关联查询的。因此至于是使用关联查询还是子查询则需要使用EXPLAIN对SQL进行分析才是万全之策。

### 7. 替换使用
【推荐】：用IN代替OR OR的效率没有IN的效率高。
【推荐】：IN条件里面的数据的个数建议控制在500个以内。
【建议】：适当使用EXISTS代替IN，EXISTS在一些场景查询会比IN快 select * from A where id in (select id from B); vs select * from A where exists (select 1 from B where A.id=B.id); 对于以上两种情况，in是在内存里遍历比较，而exists需要查询数据库，所以当B表数据量较大时，exists效率优于in。
【推荐】：用UNION ALL代替UNION。

## 五、流程规范
【强制】：所有的建表需要确定建立哪些索引后才可以建表上线；如索引仅需要主键， 必须特别说明。
【推荐】：所有的改表结构、加索引操作都需要评估：所改表的已有数据量、查询sql 性能。
【强制】：批量导入、导出数据必须提前通知运维协助观察。
【强制】：禁止有super权限的应用程序账号存在。
【推荐】：推广活动或上线新功能必须提前通知DBA进行流量评估。
【推荐】：不在业务高峰期批量更新、查询数据库，特殊情况除外。

## 六、存储过程
【强制】：OLTP和OLAP业务场景中禁止使用存储过程， 仅数据迁移过程可慎重使用。
【强制】：存储过程内部，少用局部变量，直接使用存储过程的参数变量。